{
  "version": "0.0.83",
  "files": [
    {
      "filename": "README.md",
      "content": "# spider-web-physics\n\nTo install dependencies:\n\n```bash\nbun install\n```\n\nTo run:\n\n```bash\nbun run \n```\n\nThis project was created using `bun init` in bun v1.3.9. [Bun](https://bun.com) is a fast all-in-one JavaScript runtime.\n"
    },
    {
      "filename": "bun.lock",
      "content": "{\n  \"lockfileVersion\": 1,\n  \"configVersion\": 1,\n  \"workspaces\": {\n    \"\": {\n      \"name\": \"spider-web-physics\",\n      \"dependencies\": {\n        \"@webgpu/types\": \"^0.1.43\",\n        \"react\": \"^19.2.4\",\n        \"react-dom\": \"^19.2.4\",\n        \"three\": \"^0.182.0\",\n      },\n      \"devDependencies\": {\n        \"@types/bun\": \"latest\",\n        \"@types/react\": \"^19.2.14\",\n        \"@types/react-dom\": \"^19.2.3\",\n        \"@types/three\": \"^0.182.0\",\n        \"typescript\": \"^5.3.0\",\n        \"vite\": \"^5.0.0\",\n      },\n      \"peerDependencies\": {\n        \"typescript\": \"^5\",\n      },\n    },\n  },\n  \"packages\": {\n    \"@dimforge/rapier3d-compat\": [\"@dimforge/rapier3d-compat@0.12.0\", \"\", {}, \"sha512-uekIGetywIgopfD97oDL5PfeezkFpNhwlzlaEYNOA0N6ghdsOvh/HYjSMek5Q2O1PYvRSDFcqFVJl4r4ZBwOow==\"],\n\n    \"@esbuild/aix-ppc64\": [\"@esbuild/aix-ppc64@0.21.5\", \"\", { \"os\": \"aix\", \"cpu\": \"ppc64\" }, \"sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==\"],\n\n    \"@esbuild/android-arm\": [\"@esbuild/android-arm@0.21.5\", \"\", { \"os\": \"android\", \"cpu\": \"arm\" }, \"sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==\"],\n\n    \"@esbuild/android-arm64\": [\"@esbuild/android-arm64@0.21.5\", \"\", { \"os\": \"android\", \"cpu\": \"arm64\" }, \"sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==\"],\n\n    \"@esbuild/android-x64\": [\"@esbuild/android-x64@0.21.5\", \"\", { \"os\": \"android\", \"cpu\": \"x64\" }, \"sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==\"],\n\n    \"@esbuild/darwin-arm64\": [\"@esbuild/darwin-arm64@0.21.5\", \"\", { \"os\": \"darwin\", \"cpu\": \"arm64\" }, \"sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==\"],\n\n    \"@esbuild/darwin-x64\": [\"@esbuild/darwin-x64@0.21.5\", \"\", { \"os\": \"darwin\", \"cpu\": \"x64\" }, \"sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==\"],\n\n    \"@esbuild/freebsd-arm64\": [\"@esbuild/freebsd-arm64@0.21.5\", \"\", { \"os\": \"freebsd\", \"cpu\": \"arm64\" }, \"sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==\"],\n\n    \"@esbuild/freebsd-x64\": [\"@esbuild/freebsd-x64@0.21.5\", \"\", { \"os\": \"freebsd\", \"cpu\": \"x64\" }, \"sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==\"],\n\n    \"@esbuild/linux-arm\": [\"@esbuild/linux-arm@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"arm\" }, \"sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==\"],\n\n    \"@esbuild/linux-arm64\": [\"@esbuild/linux-arm64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"arm64\" }, \"sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==\"],\n\n    \"@esbuild/linux-ia32\": [\"@esbuild/linux-ia32@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"ia32\" }, \"sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==\"],\n\n    \"@esbuild/linux-loong64\": [\"@esbuild/linux-loong64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==\"],\n\n    \"@esbuild/linux-mips64el\": [\"@esbuild/linux-mips64el@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==\"],\n\n    \"@esbuild/linux-ppc64\": [\"@esbuild/linux-ppc64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"ppc64\" }, \"sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==\"],\n\n    \"@esbuild/linux-riscv64\": [\"@esbuild/linux-riscv64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==\"],\n\n    \"@esbuild/linux-s390x\": [\"@esbuild/linux-s390x@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"s390x\" }, \"sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==\"],\n\n    \"@esbuild/linux-x64\": [\"@esbuild/linux-x64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"x64\" }, \"sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==\"],\n\n    \"@esbuild/netbsd-x64\": [\"@esbuild/netbsd-x64@0.21.5\", \"\", { \"os\": \"none\", \"cpu\": \"x64\" }, \"sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==\"],\n\n    \"@esbuild/openbsd-x64\": [\"@esbuild/openbsd-x64@0.21.5\", \"\", { \"os\": \"openbsd\", \"cpu\": \"x64\" }, \"sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==\"],\n\n    \"@esbuild/sunos-x64\": [\"@esbuild/sunos-x64@0.21.5\", \"\", { \"os\": \"sunos\", \"cpu\": \"x64\" }, \"sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==\"],\n\n    \"@esbuild/win32-arm64\": [\"@esbuild/win32-arm64@0.21.5\", \"\", { \"os\": \"win32\", \"cpu\": \"arm64\" }, \"sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==\"],\n\n    \"@esbuild/win32-ia32\": [\"@esbuild/win32-ia32@0.21.5\", \"\", { \"os\": \"win32\", \"cpu\": \"ia32\" }, \"sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==\"],\n\n    \"@esbuild/win32-x64\": [\"@esbuild/win32-x64@0.21.5\", \"\", { \"os\": \"win32\", \"cpu\": \"x64\" }, \"sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==\"],\n\n    \"@rollup/rollup-android-arm-eabi\": [\"@rollup/rollup-android-arm-eabi@4.57.1\", \"\", { \"os\": \"android\", \"cpu\": \"arm\" }, \"sha512-A6ehUVSiSaaliTxai040ZpZ2zTevHYbvu/lDoeAteHI8QnaosIzm4qwtezfRg1jOYaUmnzLX1AOD6Z+UJjtifg==\"],\n\n    \"@rollup/rollup-android-arm64\": [\"@rollup/rollup-android-arm64@4.57.1\", \"\", { \"os\": \"android\", \"cpu\": \"arm64\" }, \"sha512-dQaAddCY9YgkFHZcFNS/606Exo8vcLHwArFZ7vxXq4rigo2bb494/xKMMwRRQW6ug7Js6yXmBZhSBRuBvCCQ3w==\"],\n\n    \"@rollup/rollup-darwin-arm64\": [\"@rollup/rollup-darwin-arm64@4.57.1\", \"\", { \"os\": \"darwin\", \"cpu\": \"arm64\" }, \"sha512-crNPrwJOrRxagUYeMn/DZwqN88SDmwaJ8Cvi/TN1HnWBU7GwknckyosC2gd0IqYRsHDEnXf328o9/HC6OkPgOg==\"],\n\n    \"@rollup/rollup-darwin-x64\": [\"@rollup/rollup-darwin-x64@4.57.1\", \"\", { \"os\": \"darwin\", \"cpu\": \"x64\" }, \"sha512-Ji8g8ChVbKrhFtig5QBV7iMaJrGtpHelkB3lsaKzadFBe58gmjfGXAOfI5FV0lYMH8wiqsxKQ1C9B0YTRXVy4w==\"],\n\n    \"@rollup/rollup-freebsd-arm64\": [\"@rollup/rollup-freebsd-arm64@4.57.1\", \"\", { \"os\": \"freebsd\", \"cpu\": \"arm64\" }, \"sha512-R+/WwhsjmwodAcz65guCGFRkMb4gKWTcIeLy60JJQbXrJ97BOXHxnkPFrP+YwFlaS0m+uWJTstrUA9o+UchFug==\"],\n\n    \"@rollup/rollup-freebsd-x64\": [\"@rollup/rollup-freebsd-x64@4.57.1\", \"\", { \"os\": \"freebsd\", \"cpu\": \"x64\" }, \"sha512-IEQTCHeiTOnAUC3IDQdzRAGj3jOAYNr9kBguI7MQAAZK3caezRrg0GxAb6Hchg4lxdZEI5Oq3iov/w/hnFWY9Q==\"],\n\n    \"@rollup/rollup-linux-arm-gnueabihf\": [\"@rollup/rollup-linux-arm-gnueabihf@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"arm\" }, \"sha512-F8sWbhZ7tyuEfsmOxwc2giKDQzN3+kuBLPwwZGyVkLlKGdV1nvnNwYD0fKQ8+XS6hp9nY7B+ZeK01EBUE7aHaw==\"],\n\n    \"@rollup/rollup-linux-arm-musleabihf\": [\"@rollup/rollup-linux-arm-musleabihf@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"arm\" }, \"sha512-rGfNUfn0GIeXtBP1wL5MnzSj98+PZe/AXaGBCRmT0ts80lU5CATYGxXukeTX39XBKsxzFpEeK+Mrp9faXOlmrw==\"],\n\n    \"@rollup/rollup-linux-arm64-gnu\": [\"@rollup/rollup-linux-arm64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"arm64\" }, \"sha512-MMtej3YHWeg/0klK2Qodf3yrNzz6CGjo2UntLvk2RSPlhzgLvYEB3frRvbEF2wRKh1Z2fDIg9KRPe1fawv7C+g==\"],\n\n    \"@rollup/rollup-linux-arm64-musl\": [\"@rollup/rollup-linux-arm64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"arm64\" }, \"sha512-1a/qhaaOXhqXGpMFMET9VqwZakkljWHLmZOX48R0I/YLbhdxr1m4gtG1Hq7++VhVUmf+L3sTAf9op4JlhQ5u1Q==\"],\n\n    \"@rollup/rollup-linux-loong64-gnu\": [\"@rollup/rollup-linux-loong64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-QWO6RQTZ/cqYtJMtxhkRkidoNGXc7ERPbZN7dVW5SdURuLeVU7lwKMpo18XdcmpWYd0qsP1bwKPf7DNSUinhvA==\"],\n\n    \"@rollup/rollup-linux-loong64-musl\": [\"@rollup/rollup-linux-loong64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-xpObYIf+8gprgWaPP32xiN5RVTi/s5FCR+XMXSKmhfoJjrpRAjCuuqQXyxUa/eJTdAE6eJ+KDKaoEqjZQxh3Gw==\"],\n\n    \"@rollup/rollup-linux-ppc64-gnu\": [\"@rollup/rollup-linux-ppc64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"ppc64\" }, \"sha512-4BrCgrpZo4hvzMDKRqEaW1zeecScDCR+2nZ86ATLhAoJ5FQ+lbHVD3ttKe74/c7tNT9c6F2viwB3ufwp01Oh2w==\"],\n\n    \"@rollup/rollup-linux-ppc64-musl\": [\"@rollup/rollup-linux-ppc64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"ppc64\" }, \"sha512-NOlUuzesGauESAyEYFSe3QTUguL+lvrN1HtwEEsU2rOwdUDeTMJdO5dUYl/2hKf9jWydJrO9OL/XSSf65R5+Xw==\"],\n\n    \"@rollup/rollup-linux-riscv64-gnu\": [\"@rollup/rollup-linux-riscv64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-ptA88htVp0AwUUqhVghwDIKlvJMD/fmL/wrQj99PRHFRAG6Z5nbWoWG4o81Nt9FT+IuqUQi+L31ZKAFeJ5Is+A==\"],\n\n    \"@rollup/rollup-linux-riscv64-musl\": [\"@rollup/rollup-linux-riscv64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-S51t7aMMTNdmAMPpBg7OOsTdn4tySRQvklmL3RpDRyknk87+Sp3xaumlatU+ppQ+5raY7sSTcC2beGgvhENfuw==\"],\n\n    \"@rollup/rollup-linux-s390x-gnu\": [\"@rollup/rollup-linux-s390x-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"s390x\" }, \"sha512-Bl00OFnVFkL82FHbEqy3k5CUCKH6OEJL54KCyx2oqsmZnFTR8IoNqBF+mjQVcRCT5sB6yOvK8A37LNm/kPJiZg==\"],\n\n    \"@rollup/rollup-linux-x64-gnu\": [\"@rollup/rollup-linux-x64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"x64\" }, \"sha512-ABca4ceT4N+Tv/GtotnWAeXZUZuM/9AQyCyKYyKnpk4yoA7QIAuBt6Hkgpw8kActYlew2mvckXkvx0FfoInnLg==\"],\n\n    \"@rollup/rollup-linux-x64-musl\": [\"@rollup/rollup-linux-x64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"x64\" }, \"sha512-HFps0JeGtuOR2convgRRkHCekD7j+gdAuXM+/i6kGzQtFhlCtQkpwtNzkNj6QhCDp7DRJ7+qC/1Vg2jt5iSOFw==\"],\n\n    \"@rollup/rollup-openbsd-x64\": [\"@rollup/rollup-openbsd-x64@4.57.1\", \"\", { \"os\": \"openbsd\", \"cpu\": \"x64\" }, \"sha512-H+hXEv9gdVQuDTgnqD+SQffoWoc0Of59AStSzTEj/feWTBAnSfSD3+Dql1ZruJQxmykT/JVY0dE8Ka7z0DH1hw==\"],\n\n    \"@rollup/rollup-openharmony-arm64\": [\"@rollup/rollup-openharmony-arm64@4.57.1\", \"\", { \"os\": \"none\", \"cpu\": \"arm64\" }, \"sha512-4wYoDpNg6o/oPximyc/NG+mYUejZrCU2q+2w6YZqrAs2UcNUChIZXjtafAiiZSUc7On8v5NyNj34Kzj/Ltk6dQ==\"],\n\n    \"@rollup/rollup-win32-arm64-msvc\": [\"@rollup/rollup-win32-arm64-msvc@4.57.1\", \"\", { \"os\": \"win32\", \"cpu\": \"arm64\" }, \"sha512-O54mtsV/6LW3P8qdTcamQmuC990HDfR71lo44oZMZlXU4tzLrbvTii87Ni9opq60ds0YzuAlEr/GNwuNluZyMQ==\"],\n\n    \"@rollup/rollup-win32-ia32-msvc\": [\"@rollup/rollup-win32-ia32-msvc@4.57.1\", \"\", { \"os\": \"win32\", \"cpu\": \"ia32\" }, \"sha512-P3dLS+IerxCT/7D2q2FYcRdWRl22dNbrbBEtxdWhXrfIMPP9lQhb5h4Du04mdl5Woq05jVCDPCMF7Ub0NAjIew==\"],\n\n    \"@rollup/rollup-win32-x64-gnu\": [\"@rollup/rollup-win32-x64-gnu@4.57.1\", \"\", { \"os\": \"win32\", \"cpu\": \"x64\" }, \"sha512-VMBH2eOOaKGtIJYleXsi2B8CPVADrh+TyNxJ4mWPnKfLB/DBUmzW+5m1xUrcwWoMfSLagIRpjUFeW5CO5hyciQ==\"],\n\n    \"@rollup/rollup-win32-x64-msvc\": [\"@rollup/rollup-win32-x64-msvc@4.57.1\", \"\", { \"os\": \"win32\", \"cpu\": \"x64\" }, \"sha512-mxRFDdHIWRxg3UfIIAwCm6NzvxG0jDX/wBN6KsQFTvKFqqg9vTrWUE68qEjHt19A5wwx5X5aUi2zuZT7YR0jrA==\"],\n\n    \"@tweenjs/tween.js\": [\"@tweenjs/tween.js@23.1.3\", \"\", {}, \"sha512-vJmvvwFxYuGnF2axRtPYocag6Clbb5YS7kLL+SO/TeVFzHqDIWrNKYtcsPMibjDx9O+bu+psAy9NKfWklassUA==\"],\n\n    \"@types/bun\": [\"@types/bun@1.3.9\", \"\", { \"dependencies\": { \"bun-types\": \"1.3.9\" } }, \"sha512-KQ571yULOdWJiMH+RIWIOZ7B2RXQGpL1YQrBtLIV3FqDcCu6FsbFUBwhdKUlCKUpS3PJDsHlJ1QKlpxoVR+xtw==\"],\n\n    \"@types/estree\": [\"@types/estree@1.0.8\", \"\", {}, \"sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==\"],\n\n    \"@types/node\": [\"@types/node@25.2.3\", \"\", { \"dependencies\": { \"undici-types\": \"~7.16.0\" } }, \"sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==\"],\n\n    \"@types/react\": [\"@types/react@19.2.14\", \"\", { \"dependencies\": { \"csstype\": \"^3.2.2\" } }, \"sha512-ilcTH/UniCkMdtexkoCN0bI7pMcJDvmQFPvuPvmEaYA/NSfFTAgdUSLAoVjaRJm7+6PvcM+q1zYOwS4wTYMF9w==\"],\n\n    \"@types/react-dom\": [\"@types/react-dom@19.2.3\", \"\", { \"peerDependencies\": { \"@types/react\": \"^19.2.0\" } }, \"sha512-jp2L/eY6fn+KgVVQAOqYItbF0VY/YApe5Mz2F0aykSO8gx31bYCZyvSeYxCHKvzHG5eZjc+zyaS5BrBWya2+kQ==\"],\n\n    \"@types/stats.js\": [\"@types/stats.js@0.17.4\", \"\", {}, \"sha512-jIBvWWShCvlBqBNIZt0KAshWpvSjhkwkEu4ZUcASoAvhmrgAUI2t1dXrjSL4xXVLB4FznPrIsX3nKXFl/Dt4vA==\"],\n\n    \"@types/three\": [\"@types/three@0.182.0\", \"\", { \"dependencies\": { \"@dimforge/rapier3d-compat\": \"~0.12.0\", \"@tweenjs/tween.js\": \"~23.1.3\", \"@types/stats.js\": \"*\", \"@types/webxr\": \">=0.5.17\", \"@webgpu/types\": \"*\", \"fflate\": \"~0.8.2\", \"meshoptimizer\": \"~0.22.0\" } }, \"sha512-WByN9V3Sbwbe2OkWuSGyoqQO8Du6yhYaXtXLoA5FkKTUJorZ+yOHBZ35zUUPQXlAKABZmbYp5oAqpA4RBjtJ/Q==\"],\n\n    \"@types/webxr\": [\"@types/webxr@0.5.24\", \"\", {}, \"sha512-h8fgEd/DpoS9CBrjEQXR+dIDraopAEfu4wYVNY2tEPwk60stPWhvZMf4Foo5FakuQ7HFZoa8WceaWFervK2Ovg==\"],\n\n    \"@webgpu/types\": [\"@webgpu/types@0.1.69\", \"\", {}, \"sha512-RPmm6kgRbI8e98zSD3RVACvnuktIja5+yLgDAkTmxLr90BEwdTXRQWNLF3ETTTyH/8mKhznZuN5AveXYFEsMGQ==\"],\n\n    \"bun-types\": [\"bun-types@1.3.9\", \"\", { \"dependencies\": { \"@types/node\": \"*\" } }, \"sha512-+UBWWOakIP4Tswh0Bt0QD0alpTY8cb5hvgiYeWCMet9YukHbzuruIEeXC2D7nMJPB12kbh8C7XJykSexEqGKJg==\"],\n\n    \"csstype\": [\"csstype@3.2.3\", \"\", {}, \"sha512-z1HGKcYy2xA8AGQfwrn0PAy+PB7X/GSj3UVJW9qKyn43xWa+gl5nXmU4qqLMRzWVLFC8KusUX8T/0kCiOYpAIQ==\"],\n\n    \"esbuild\": [\"esbuild@0.21.5\", \"\", { \"optionalDependencies\": { \"@esbuild/aix-ppc64\": \"0.21.5\", \"@esbuild/android-arm\": \"0.21.5\", \"@esbuild/android-arm64\": \"0.21.5\", \"@esbuild/android-x64\": \"0.21.5\", \"@esbuild/darwin-arm64\": \"0.21.5\", \"@esbuild/darwin-x64\": \"0.21.5\", \"@esbuild/freebsd-arm64\": \"0.21.5\", \"@esbuild/freebsd-x64\": \"0.21.5\", \"@esbuild/linux-arm\": \"0.21.5\", \"@esbuild/linux-arm64\": \"0.21.5\", \"@esbuild/linux-ia32\": \"0.21.5\", \"@esbuild/linux-loong64\": \"0.21.5\", \"@esbuild/linux-mips64el\": \"0.21.5\", \"@esbuild/linux-ppc64\": \"0.21.5\", \"@esbuild/linux-riscv64\": \"0.21.5\", \"@esbuild/linux-s390x\": \"0.21.5\", \"@esbuild/linux-x64\": \"0.21.5\", \"@esbuild/netbsd-x64\": \"0.21.5\", \"@esbuild/openbsd-x64\": \"0.21.5\", \"@esbuild/sunos-x64\": \"0.21.5\", \"@esbuild/win32-arm64\": \"0.21.5\", \"@esbuild/win32-ia32\": \"0.21.5\", \"@esbuild/win32-x64\": \"0.21.5\" }, \"bin\": { \"esbuild\": \"bin/esbuild\" } }, \"sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==\"],\n\n    \"fflate\": [\"fflate@0.8.2\", \"\", {}, \"sha512-cPJU47OaAoCbg0pBvzsgpTPhmhqI5eJjh/JIu8tPj5q+T7iLvW/JAYUqmE7KOB4R1ZyEhzBaIQpQpardBF5z8A==\"],\n\n    \"fsevents\": [\"fsevents@2.3.3\", \"\", { \"os\": \"darwin\" }, \"sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==\"],\n\n    \"meshoptimizer\": [\"meshoptimizer@0.22.0\", \"\", {}, \"sha512-IebiK79sqIy+E4EgOr+CAw+Ke8hAspXKzBd0JdgEmPHiAwmvEj2S4h1rfvo+o/BnfEYd/jAOg5IeeIjzlzSnDg==\"],\n\n    \"nanoid\": [\"nanoid@3.3.11\", \"\", { \"bin\": { \"nanoid\": \"bin/nanoid.cjs\" } }, \"sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==\"],\n\n    \"picocolors\": [\"picocolors@1.1.1\", \"\", {}, \"sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==\"],\n\n    \"postcss\": [\"postcss@8.5.6\", \"\", { \"dependencies\": { \"nanoid\": \"^3.3.11\", \"picocolors\": \"^1.1.1\", \"source-map-js\": \"^1.2.1\" } }, \"sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==\"],\n\n    \"react\": [\"react@19.2.4\", \"\", {}, \"sha512-9nfp2hYpCwOjAN+8TZFGhtWEwgvWHXqESH8qT89AT/lWklpLON22Lc8pEtnpsZz7VmawabSU0gCjnj8aC0euHQ==\"],\n\n    \"react-dom\": [\"react-dom@19.2.4\", \"\", { \"dependencies\": { \"scheduler\": \"^0.27.0\" }, \"peerDependencies\": { \"react\": \"^19.2.4\" } }, \"sha512-AXJdLo8kgMbimY95O2aKQqsz2iWi9jMgKJhRBAxECE4IFxfcazB2LmzloIoibJI3C12IlY20+KFaLv+71bUJeQ==\"],\n\n    \"rollup\": [\"rollup@4.57.1\", \"\", { \"dependencies\": { \"@types/estree\": \"1.0.8\" }, \"optionalDependencies\": { \"@rollup/rollup-android-arm-eabi\": \"4.57.1\", \"@rollup/rollup-android-arm64\": \"4.57.1\", \"@rollup/rollup-darwin-arm64\": \"4.57.1\", \"@rollup/rollup-darwin-x64\": \"4.57.1\", \"@rollup/rollup-freebsd-arm64\": \"4.57.1\", \"@rollup/rollup-freebsd-x64\": \"4.57.1\", \"@rollup/rollup-linux-arm-gnueabihf\": \"4.57.1\", \"@rollup/rollup-linux-arm-musleabihf\": \"4.57.1\", \"@rollup/rollup-linux-arm64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-arm64-musl\": \"4.57.1\", \"@rollup/rollup-linux-loong64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-loong64-musl\": \"4.57.1\", \"@rollup/rollup-linux-ppc64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-ppc64-musl\": \"4.57.1\", \"@rollup/rollup-linux-riscv64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-riscv64-musl\": \"4.57.1\", \"@rollup/rollup-linux-s390x-gnu\": \"4.57.1\", \"@rollup/rollup-linux-x64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-x64-musl\": \"4.57.1\", \"@rollup/rollup-openbsd-x64\": \"4.57.1\", \"@rollup/rollup-openharmony-arm64\": \"4.57.1\", \"@rollup/rollup-win32-arm64-msvc\": \"4.57.1\", \"@rollup/rollup-win32-ia32-msvc\": \"4.57.1\", \"@rollup/rollup-win32-x64-gnu\": \"4.57.1\", \"@rollup/rollup-win32-x64-msvc\": \"4.57.1\", \"fsevents\": \"~2.3.2\" }, \"bin\": { \"rollup\": \"dist/bin/rollup\" } }, \"sha512-oQL6lgK3e2QZeQ7gcgIkS2YZPg5slw37hYufJ3edKlfQSGGm8ICoxswK15ntSzF/a8+h7ekRy7k7oWc3BQ7y8A==\"],\n\n    \"scheduler\": [\"scheduler@0.27.0\", \"\", {}, \"sha512-eNv+WrVbKu1f3vbYJT/xtiF5syA5HPIMtf9IgY/nKg0sWqzAUEvqY/xm7OcZc/qafLx/iO9FgOmeSAp4v5ti/Q==\"],\n\n    \"source-map-js\": [\"source-map-js@1.2.1\", \"\", {}, \"sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==\"],\n\n    \"three\": [\"three@0.182.0\", \"\", {}, \"sha512-GbHabT+Irv+ihI1/f5kIIsZ+Ef9Sl5A1Y7imvS5RQjWgtTPfPnZ43JmlYI7NtCRDK9zir20lQpfg8/9Yd02OvQ==\"],\n\n    \"typescript\": [\"typescript@5.9.3\", \"\", { \"bin\": { \"tsc\": \"bin/tsc\", \"tsserver\": \"bin/tsserver\" } }, \"sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==\"],\n\n    \"undici-types\": [\"undici-types@7.16.0\", \"\", {}, \"sha512-Zz+aZWSj8LE6zoxD+xrjh4VfkIG8Ya6LvYkZqtUQGJPZjYl53ypCaUwWqo7eI0x66KBGeRo+mlBEkMSeSZ38Nw==\"],\n\n    \"vite\": [\"vite@5.4.21\", \"\", { \"dependencies\": { \"esbuild\": \"^0.21.3\", \"postcss\": \"^8.4.43\", \"rollup\": \"^4.20.0\" }, \"optionalDependencies\": { \"fsevents\": \"~2.3.3\" }, \"peerDependencies\": { \"@types/node\": \"^18.0.0 || >=20.0.0\", \"less\": \"*\", \"lightningcss\": \"^1.21.0\", \"sass\": \"*\", \"sass-embedded\": \"*\", \"stylus\": \"*\", \"sugarss\": \"*\", \"terser\": \"^5.4.0\" }, \"optionalPeers\": [\"@types/node\", \"less\", \"lightningcss\", \"sass\", \"sass-embedded\", \"stylus\", \"sugarss\", \"terser\"], \"bin\": { \"vite\": \"bin/vite.js\" } }, \"sha512-o5a9xKjbtuhY6Bi5S3+HvbRERmouabWbyUcpXXUA1u+GNUKoROi9byOJ8M0nHbHYHkYICiMlqxkg1KkYmm25Sw==\"],\n  }\n}\n"
    },
    {
      "filename": "index.html",
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Web-Builder Editor</title>\n    <style>\n        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }\n        #root { width: 100vw; height: 100vh; }\n    </style>\n</head>\n<body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"/src/main.tsx\"></script>\n</body>\n</html>"
    },
    {
      "filename": "mvp.md",
      "content": "Oto definicja MVP dla Twojej gry „Web-Builder 2D” na WebGPU:\n1. Świat Gry (Środowisko)\nProstokątne „Akwarium”: Granice ekranu stanowią twarde kolizje.\nWektor Wiatru: Globalna zmienna uniform vec2 windForce, która co klatkę dodaje siłę do każdego wolnego węzła.\n2. Fizyka (Compute Shader / PBD)\nUżyjemy Position Based Dynamics, bo jest najbardziej stabilne dla sznurków i WebGPU.\nBufor Punktów (Particles): Każdy punkt ma: position, old_position, mass (0 dla punktów przytwierdzonych).\nBufor Wiązań (Constraints): Indeks punktu A, indeks punktu B, rest_length (długość spoczynkowa).\nKrok Fizyki:\nAplikacja wiatru i grawitacji (nowa pozycja).\nRozwiązanie wiązań (pętla iteracyjna – pociąganie punktów ku sobie, by zachować rest_length).\nKolizja ze ścianami (jeśli pos.x < 0, to pos.x = 0).\n3. Pająk (Gracz) – Logika i Sterowanie\nPająk jest specjalnym „super-węzłem” w systemie fizycznym. Ma dwa stany:\nA. Stan: Chodzenie (On Wall/Ceiling)\nPająk jest „przyklejony” do ściany (jego masa w shaderze = 0, lub ignorujemy siły zewnętrzne).\nRuch: Zmieniamy jego współrzędne bezpośrednio na podstawie klawiszy (L/P/G/D).\nJump: Odlepia pająka od ściany, nadaje mu prędkość początkową i zmienia stan na IN_AIR.\nB. Stan: Wiszenie/Lot (In Air)\nPająk staje się zwykłym punktem fizycznym podlegającym grawitacji i wiatrowi.\nWytwarzanie liny: Jeśli pająk skacze, automatycznie tworzy się pierwsze wiązanie między punktem na ścianie (kotwicą) a pająkiem.\n4. Mechanika Liny (Dynamiczne Wiązania)\nTo jest serce gry. Musisz zarządzać listą węzłów liny, którą pająk „rozwija”.\nRozwijanie: Jeśli pająk oddali się od ostatniego węzła o więcej niż X metrów, shader/skrypt dodaje nowy węzeł w miejscu pająka i tworzy nowe wiązanie między pająkiem a tym nowym węzłem.\nZwijanie/Rozwijanie (Góra/Dół):\nZamiast dodawać węzły, zmieniasz parametr rest_length ostatniego odcinka (tego przy pająku).\nJeśli rest_length spadnie do 0 – usuwasz segment.\nJeśli wzrośnie powyżej limitu – dodajesz nowy segment.\nPrzypnij (Pin): Kiedy pająk dotknie dowolnej ściany podczas wiszenia na linie, ostatni węzeł (przy pająku) zostaje zamieniony na „kotwicę” (masa = 0). Lina zostaje w świecie, a pająk jest wolny.\n5. Technologia (WebGPU + Three.js)\nCompute Shader: Liczy wszystkie Constraints i Particle Positions.\nThree.js: Używamy InstancedMesh (dla małych kulek-węzłów) oraz LineSegments do wizualizacji nici.\nProTip: WebGPU pozwala na Storage Buffer sharing. Oznacza to, że Compute Shader zapisuje pozycje prosto do bufora, który Three.js odczytuje jako bufor wierzchołków (Vertex Buffer) bez przesyłania danych przez CPU!\nScenariusz MVP (User Flow):\nPająk siedzi na lewej ścianie.\nGracz klika JUMP -> Pająk leci w prawo. Silnik tworzy „Kotwicę” na lewej ścianie i nitkę do pająka.\nPająk leci po łuku (wahadło). Gracz trzyma GÓRĘ -> lina się skraca, pająk podciąga się wyżej.\nPająk dolatuje do sufitu. Gracz klika PIN -> Nitka zostaje przymocowana do sufitu.\nMamy teraz nitkę rozpiętą między lewą ścianą a sufitem.\nPająk może teraz przejść po suficie i skoczyć z innego miejsca, budując kolejną nitkę."
    },
    {
      "filename": "package.json",
      "content": "{\n  \"name\": \"spider-web-physics\",\n  \"private\": true,\n  \"version\": \"0.0.83\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\"\n  },\n  \"dependencies\": {\n    \"@webgpu/types\": \"^0.1.43\",\n    \"react\": \"^19.2.4\",\n    \"react-dom\": \"^19.2.4\",\n    \"three\": \"^0.182.0\"\n  },\n  \"devDependencies\": {\n    \"@types/bun\": \"latest\",\n    \"@types/react\": \"^19.2.14\",\n    \"@types/react-dom\": \"^19.2.3\",\n    \"@types/three\": \"^0.182.0\",\n    \"typescript\": \"^5.3.0\",\n    \"vite\": \"^5.0.0\"\n  },\n  \"peerDependencies\": {\n    \"typescript\": \"^5\"\n  }\n}\n"
    },
    {
      "filename": "requirements.md",
      "content": "# Web-Builder 2D Requirements\n\n## Functional Requirements\n- **Spider Movement (Wall/Ceiling):**\n  - Smooth movement along the 2D boundaries (Left, Right, Up, Down).\n  - Spider should automatically stick to walls/ceiling when touching them.\n- **Jump Mechanic:**\n  - Pressing Space detaches the spider from the wall.\n  - Initial velocity applied in the direction of the jump.\n- **Web Creation (Rope):**\n  - A line starts from the point where the spider jumped.\n  - The line follows the spider in the air.\n  - Rope length can be adjusted (Up/Down keys while in air).\n- **Pinning:**\n  - Pressing 'E' or touching another wall while in air attaches the current line permanently.\n- **Environment:**\n  - 2D rectangular box as boundaries.\n  - Constant gravity and a variable wind vector.\n\n## Technical Requirements\n- **Renderer:** Three.js using `WebGPURenderer`.\n- **Physics Engine:** Custom Compute Shader based on Position Based Dynamics (PBD).\n- **State Management:** Simple state machine for the spider (IDLE, CLIMBING, IN_AIR).\n- **Performance:** Target 60 FPS with thousands of rope segments using GPU buffers."
    },
    {
      "filename": "src/main.tsx",
      "content": "import React, { useEffect, useRef, useState } from 'react';\nimport ReactDOM from 'react-dom/client';\nimport * as THREE from 'three';\n// @ts-ignore\nimport WebGPURenderer from 'three/src/renderers/webgpu/WebGPURenderer.js';\nimport { WebPhysics } from './webPhysics';\n\nconst BOUNDS = { width: 24, height: 14 };\n\nconst App = () => {\n    const canvasRef = useRef<HTMLDivElement>(null);\n    const physicsRef = useRef<WebPhysics | null>(null);\n    const [tool, setTool] = useState<'select' | 'circle' | 'box'>('select');\n    const [activeRope, setActiveRope] = useState(false);\n    const [fps, setFps] = useState(0);\n\n    useEffect(() => {\n        if (!canvasRef.current) return;\n\n        let scene: THREE.Scene, camera: THREE.OrthographicCamera, renderer: any;\n        let mouseWorld = new THREE.Vector2();\n        let frameCount = 0, lastTime = performance.now();\n\n        const init = async () => {\n            scene = new THREE.Scene();\n            camera = new THREE.OrthographicCamera(-BOUNDS.width/2, BOUNDS.width/2, BOUNDS.height/2, -BOUNDS.height/2, 0.1, 1000);\n            camera.position.z = 10;\n\n            renderer = new WebGPURenderer({ antialias: true });\n            renderer.setSize(window.innerWidth, window.innerHeight);\n            canvasRef.current?.appendChild(renderer.domElement);\n\n            await renderer.init();\n            const physics = new WebPhysics(renderer, scene, BOUNDS);\n            await physics.init();\n            physicsRef.current = physics;\n\n            // Visual Frame\n            const frameMat = new THREE.LineBasicMaterial({ color: 0x333333 });\n            const frameGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(BOUNDS.width - 0.2, BOUNDS.height - 0.2, 0));\n            scene.add(new THREE.LineSegments(frameGeo, frameMat));\n\n            const animate = () => {\n                const now = performance.now();\n                frameCount++;\n                if (now - lastTime >= 1000) {\n                    setFps(frameCount);\n                    frameCount = 0;\n                    lastTime = now;\n                }\n\n                if (physics.ready) {\n                    physics.update(mouseWorld);\n                    setActiveRope(physics.activeRope !== null);\n                }\n                renderer.render(scene, camera);\n                requestAnimationFrame(animate);\n            };\n\n            const onMouseMove = (e: MouseEvent) => {\n                const x = (e.clientX / window.innerWidth) * 2 - 1;\n                const y = -(e.clientY / window.innerHeight) * 2 + 1;\n                mouseWorld.set(x * (BOUNDS.width / 2), y * (BOUNDS.height / 2));\n            };\n\n            const onMouseDown = (e: MouseEvent) => {\n                if (!physics.ready) return;\n                // In 'select' mode we do rope mechanics\n                const anchor = physics.findAnchor(mouseWorld);\n                if (physics.activeRope) {\n                    if (anchor) physics.pinActiveRope(physics.activeRope, anchor);\n                } else if (anchor) {\n                    physics.createRope(anchor);\n                }\n            };\n\n            window.addEventListener('mousemove', onMouseMove);\n            window.addEventListener('mousedown', onMouseDown);\n            window.addEventListener('wheel', (e) => {\n                if (physics.activeRope) physics.adjustRopeLength(physics.activeRope, e.deltaY);\n            });\n\n            animate();\n        };\n\n        init();\n    }, []);\n\n    const addObstacle = (type: 'circle' | 'box') => {\n        if (!physicsRef.current) return;\n        const pos = new THREE.Vector2(Math.random() * 4 - 2, Math.random() * 4 - 2);\n        if (type === 'circle') physicsRef.current.addObstacle(pos, new THREE.Vector2(1, 0), 0);\n        else physicsRef.current.addObstacle(pos, new THREE.Vector2(1.5, 1.5), 1);\n    };\n\n    return (\n        <div style={{ position: 'relative', width: '100%', height: '100%' }}>\n            <div ref={canvasRef} />\n            <div style={{ position: 'absolute', top: 20, left: 20, background: 'rgba(0,0,0,0.8)', padding: 15, borderRadius: 8, pointerEvents: 'auto' }}>\n                <h3 style={{ margin: '0 0 10px 0' }}>Web-Builder Editor</h3>\n                <div style={{ fontSize: 12, marginBottom: 10 }}>FPS: {fps} | Rope: {activeRope ? 'YES' : 'NO'}</div>\n                <div style={{ display: 'flex', flexDirection: 'column', gap: 5 }}>\n                    <button onClick={() => setTool('select')} style={{ background: tool === 'select' ? '#444' : '#222', color: 'white' }}>Select / Web</button>\n                    <button onClick={() => addObstacle('circle')}>+ Circle Obstacle</button>\n                    <button onClick={() => addObstacle('box')}>+ Box Obstacle</button>\n                    <hr style={{ border: '0.5px solid #444', width: '100%' }} />\n                    <button onClick={() => physicsRef.current?.spawnBall(new THREE.Vector2(0,5))}>Spawn Physics Ball (Q)</button>\n                </div>\n            </div>\n        </div>\n    );\n};\n\nReactDOM.createRoot(document.getElementById('root')!).render(<App />);"
    },
    {
      "filename": "src/physics.wgsl",
      "content": "struct Particle {\n    pos: vec2<f32>,\n    oldPos: vec2<f32>,\n    vel: vec2<f32>,\n    invMass: f32,\n    radius: f32,\n};\n\nstruct DistanceConstraint {\n    idxA: u32,\n    idxB: u32,\n    restLength: f32,\n    compliance: f32,\n};\n\nstruct Attachment {\n    pIdx: u32,\n    aIdx: u32,\n    bIdx: u32,\n    t: f32,\n};\n\nstruct Obstacle {\n    pos: vec2<f32>,\n    size: vec2<f32>, // x: radius OR width, y: height\n    type_id: u32,    // 0: circle, 1: box\n    padding: u32,\n};\n\nstruct Params {\n    dt: f32,\n    gravity: f32,\n    numParticles: u32,\n    numDistConstraints: u32,\n    substeps: u32,\n    phase: u32,\n    mousePos: vec2<f32>,\n    activeParticleIdx: i32,\n    numAttachments: u32,\n    damping: f32,\n    pendulumIdx: i32,\n    numObstacles: u32,\n};\n\n@group(0) @binding(0) var<storage, read_write> particles: array<Particle>;\n@group(0) @binding(1) var<storage, read> distConstraints: array<DistanceConstraint>;\n@group(0) @binding(2) var<storage, read> attachments: array<Attachment>;\n@group(0) @binding(3) var<uniform> params: Params;\n@group(0) @binding(4) var<storage, read> obstacles: array<Obstacle>;\n\n@compute @workgroup_size(64)\nfn integrate(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x;\n    if (i >= params.numParticles) { return; }\n    var p = particles[i];\n    if (i == u32(params.activeParticleIdx)) {\n        particles[i].pos = params.mousePos;\n        particles[i].oldPos = params.mousePos;\n        return;\n    }\n    if (p.invMass <= 0.0) { return; }\n    let h = params.dt / f32(params.substeps);\n    var vel = (p.pos - p.oldPos) / h;\n    vel = vel * params.damping;\n    vel = vel + vec2<f32>(0.0, params.gravity) * h;\n    particles[i].oldPos = p.pos;\n    particles[i].pos = p.pos + vel * h;\n}\n\n@compute @workgroup_size(64)\nfn solveDistance(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x;\n    if (i >= params.numDistConstraints || i % 2u != params.phase) { return; }\n    let c = distConstraints[i];\n    let w1 = particles[c.idxA].invMass; let w2 = particles[c.idxB].invMass;\n    let wSum = w1 + w2; if (wSum <= 0.0) { return; }\n    let delta = particles[c.idxA].pos - particles[c.idxB].pos;\n    let dist = length(delta); if (dist < 0.0001) { return; }\n    let h = params.dt / f32(params.substeps);\n    let alpha = c.compliance / (h * h);\n    let dLambda = -(dist - c.restLength) / (wSum + alpha);\n    let correction = delta * (dLambda / dist);\n    if (w1 > 0.0) { particles[c.idxA].pos += correction * w1; }\n    if (w2 > 0.0) { particles[c.idxB].pos -= correction * w2; }\n}\n\n@compute @workgroup_size(64)\nfn solveAttachments(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x; if (i >= params.numAttachments) { return; }\n    let att = attachments[i];\n    let p = particles[att.pIdx].pos;\n    let a = particles[att.aIdx].pos;\n    let b = particles[att.bIdx].pos;\n    let link_target = mix(a, b, att.t);\n    let delta = p - link_target; let dist = length(delta); if (dist < 0.00001) { return; }\n    let wp = particles[att.pIdx].invMass; let wa = particles[att.aIdx].invMass; let wb = particles[att.bIdx].invMass;\n    let wSum = wp + wa * (1.0 - att.t) * (1.0 - att.t) + wb * att.t * att.t;\n    if (wSum <= 0.0) { return; }\n    let correction = normalize(delta) * (-dist / wSum);\n    if (wp > 0.0) { particles[att.pIdx].pos += correction * wp; }\n    if (wa > 0.0) { particles[att.aIdx].pos -= correction * wa * (1.0 - att.t); }\n    if (wb > 0.0) { particles[att.bIdx].pos -= correction * wb * att.t; }\n}\n\n@compute @workgroup_size(64)\nfn solveCollisions(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x; if (i >= params.numParticles) { return; }\n    var p = particles[i]; if (p.invMass <= 0.0) { return; }\n\n    // Bound collisions\n    let bx = 11.8; let by = 6.8;\n    if (p.pos.x > bx - p.radius) { p.pos.x = bx - p.radius; p.oldPos.x = p.pos.x; }\n    if (p.pos.x < -bx + p.radius) { p.pos.x = -bx + p.radius; p.oldPos.x = p.pos.x; }\n    if (p.pos.y > by - p.radius) { p.pos.y = by - p.radius; p.oldPos.y = p.pos.y; }\n    if (p.pos.y < -by + p.radius) { p.pos.y = -by + p.radius; p.oldPos.y = p.pos.y; }\n\n    // Obstacle collisions (SDF style)\n    for (var j: u32 = 0u; j < params.numObstacles; j++) {\n        let obs = obstacles[j];\n        if (obs.type_id == 0u) { // Circle\n            let toP = p.pos - obs.pos;\n            let dist = length(toP);\n            if (dist < obs.size.x + p.radius) {\n                p.pos = obs.pos + normalize(toP) * (obs.size.x + p.radius);\n                p.oldPos = p.pos;\n            }\n        } else { // Box (AABB)\n            let half = obs.size * 0.5;\n            let d = abs(p.pos - obs.pos) - half;\n            let dist = length(max(d, vec2<f32>(0.0))) + min(max(d.x, d.y), 0.0);\n            if (dist < p.radius) {\n                // Simplest projection\n                let n = select(vec2<f32>(sign(p.pos - obs.pos).x, 0.0), vec2<f32>(0.0, sign(p.pos - obs.pos).y), d.y > d.x);\n                p.pos += n * (p.radius - dist);\n                p.oldPos = p.pos;\n            }\n        }\n    }\n\n    // Pendulum collision\n    if (params.pendulumIdx >= 0 && i != u32(params.pendulumIdx)) {\n        let penPos = particles[params.pendulumIdx].pos;\n        let penRad = particles[params.pendulumIdx].radius;\n        let toP = p.pos - penPos; let dP = length(toP);\n        if (dP < penRad + p.radius) {\n            p.pos = penPos + normalize(toP) * (penRad + p.radius);\n        }\n    }\n    particles[i].pos = p.pos;\n}\n\n@compute @workgroup_size(64)\nfn solveParticleCollisions(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x; if (i >= params.numParticles) { return; }\n    var pi = particles[i]; if (pi.invMass <= 0.0) { return; }\n    for (var j: u32 = 0u; j < params.numParticles; j++) {\n        if (i == j) { continue; }\n        let pj = particles[j];\n        let delta = pi.pos - pj.pos; let dist = length(delta); let minDist = pi.radius + pj.radius;\n        if (dist < minDist && dist > 0.0001) {\n            let n = delta / dist; let overlap = minDist - dist; let wSum = pi.invMass + pj.invMass;\n            if (wSum > 0.0) { pi.pos += n * (overlap / wSum) * pi.invMass * 0.5; }\n        }\n    }\n    particles[i].pos = pi.pos;\n}"
    },
    {
      "filename": "src/webPhysics.ts",
      "content": "import * as THREE from 'three';\n\nexport const CONFIG = {\n    SEGMENT_LENGTH: 0.08,\n    ROPE_NODE_MASS: 1.0,\n    ROPE_COMPLIANCE: 0.00001,\n    VELOCITY_DAMPING: 0.992,\n    GRAVITY: -15.0,\n    PENDULUM_RADIUS: 1.2,\n    PENDULUM_LENGTH: 4.0\n};\n\nconst MAX_PARTICLES = 16384;\nconst MAX_CONSTRAINTS = 16384;\nconst MAX_ATTACHMENTS = 4096;\nconst MAX_OBSTACLES = 256;\n\nexport class WebPhysics {\n    renderer: any; scene: THREE.Scene; bounds: { width: number; height: number }; ready: boolean = false;\n    particles = new Float32Array(MAX_PARTICLES * 8);\n    distConstraints = new Float32Array(MAX_CONSTRAINTS * 4);\n    attachments = new Float32Array(MAX_ATTACHMENTS * 4);\n    obstacles = new Float32Array(MAX_OBSTACLES * 8); // pos(2), size(2), type(1), pad(3)\n\n    numParticles = 0; numDistConstraints = 0; numAttachments = 0; numObstacles = 0;\n    ropes: any[] = []; balls: any[] = []; activeRope: any = null; pendulum: any = null;\n    dirtyParticles = new Set<number>(); freeParticleIndices: number[] = []; freeConstraintIndices: number[] = [];\n\n    device: GPUDevice | null = null;\n    particleBuffer: GPUBuffer | null = null; distConstraintBuffer: GPUBuffer | null = null;\n    attachmentBuffer: GPUBuffer | null = null; obstacleBuffer: GPUBuffer | null = null;\n    paramsBuffer0: GPUBuffer | null = null; paramsBuffer1: GPUBuffer | null = null; stagingBuffer: GPUBuffer | null = null;\n    bindGroup0: GPUBindGroup | null = null; bindGroup1: GPUBindGroup | null = null;\n    pipelines: Record<string, GPUComputePipeline> = {}; isReadingBack = false;\n\n    constructor(renderer: any, scene: THREE.Scene, bounds: { width: number; height: number }) {\n        this.renderer = renderer; this.scene = scene; this.bounds = bounds;\n    }\n\n    async init() {\n        const device = this.renderer.device || this.renderer.backend?.device;\n        if (!device) throw new Error('WebGPU device not found');\n        this.device = device;\n\n        const shaderCode = await (await fetch('/src/physics.wgsl')).text();\n        const shaderModule = device.createShaderModule({ code: shaderCode });\n\n        this.particleBuffer = device.createBuffer({ size: this.particles.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });\n        this.distConstraintBuffer = device.createBuffer({ size: this.distConstraints.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });\n        this.attachmentBuffer = device.createBuffer({ size: this.attachments.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });\n        this.obstacleBuffer = device.createBuffer({ size: this.obstacles.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });\n\n        this.paramsBuffer0 = device.createBuffer({ size: 96, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });\n        this.paramsBuffer1 = device.createBuffer({ size: 96, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });\n        this.stagingBuffer = device.createBuffer({ size: this.particles.byteLength, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST });\n\n        const bgl = device.createBindGroupLayout({\n            entries: [\n                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },\n                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },\n                { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },\n                { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }\n            ]\n        });\n\n        const createBG = (pBuf: GPUBuffer) => device.createBindGroup({\n            layout: bgl,\n            entries: [\n                { binding: 0, resource: { buffer: this.particleBuffer! } },\n                { binding: 1, resource: { buffer: this.distConstraintBuffer! } },\n                { binding: 2, resource: { buffer: this.attachmentBuffer! } },\n                { binding: 3, resource: { buffer: pBuf } },\n                { binding: 4, resource: { buffer: this.obstacleBuffer! } }\n            ]\n        });\n\n        this.bindGroup0 = createBG(this.paramsBuffer0!); this.bindGroup1 = createBG(this.paramsBuffer1!);\n        const layout = device.createPipelineLayout({ bindGroupLayouts: [bgl] });\n        const createPipe = (entry: string) => device.createComputePipeline({ layout, compute: { module: shaderModule, entryPoint: entry } });\n\n        ['integrate', 'solveDistance', 'solveAttachments', 'solveParticleCollisions', 'solveCollisions'].forEach(e => this.pipelines[e] = createPipe(e));\n        this.setupPendulum();\n        this.ready = true;\n    }\n\n    addObstacle(pos: THREE.Vector2, size: THREE.Vector2, type: number) {\n        if (this.numObstacles >= MAX_OBSTACLES) return;\n        const off = this.numObstacles * 8;\n        this.obstacles[off] = pos.x; this.obstacles[off+1] = pos.y;\n        this.obstacles[off+2] = size.x; this.obstacles[off+3] = size.y;\n        const uv = new Uint32Array(this.obstacles.buffer);\n        uv[off+4] = type;\n        this.numObstacles++;\n        \n        const mat = new THREE.MeshBasicMaterial({ color: 0x222222 });\n        const geo = type === 0 ? new THREE.CircleGeometry(size.x, 32) : new THREE.BoxGeometry(size.x, size.y, 0.1);\n        const mesh = new THREE.Mesh(geo, mat);\n        mesh.position.set(pos.x, pos.y, -0.5);\n        this.scene.add(mesh);\n        this.device?.queue.writeBuffer(this.obstacleBuffer!, 0, this.obstacles);\n    }\n\n    setupPendulum() {\n        const pIdx = this.allocParticle(); const bIdx = this.allocParticle();\n        const pivotPos = new THREE.Vector2(-6, 4);\n        this.setParticle(pIdx, pivotPos, 0); this.setParticle(bIdx, pivotPos.clone().add(new THREE.Vector2(4, 0)), 0.2);\n        this.particles[bIdx * 8 + 7] = CONFIG.PENDULUM_RADIUS;\n        const cIdx = this.allocConstraint(); this.setDistConstraint(cIdx, pIdx, bIdx, 4, 0);\n        const mesh = new THREE.Mesh(new THREE.CircleGeometry(CONFIG.PENDULUM_RADIUS, 32), new THREE.MeshBasicMaterial({ color: 0x4444aa }));\n        const arm = new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]), new THREE.LineBasicMaterial({ color: 0x222222 }));\n        this.scene.add(mesh, arm); this.pendulum = { pivotIdx: pIdx, ballIdx: bIdx, mesh, arm };\n        this.syncGPU();\n    }\n\n    allocParticle() { return this.freeParticleIndices.length > 0 ? this.freeParticleIndices.pop()! : this.numParticles++; }\n    freeParticle(idx: number) { this.freeParticleIndices.push(idx); this.setParticle(idx, new THREE.Vector2(0,0), 0); }\n    allocConstraint() { return this.freeConstraintIndices.length > 0 ? this.freeConstraintIndices.pop()! : this.numDistConstraints++; }\n    freeConstraint(idx: number) { this.freeConstraintIndices.push(idx); this.setDistConstraint(idx, 0,0,0,0); }\n\n    setParticle(i: number, pos: THREE.Vector2, invMass: number) {\n        const off = i * 8; this.particles[off] = pos.x; this.particles[off+1] = pos.y; this.particles[off+2] = pos.x; this.particles[off+3] = pos.y; this.particles[off+6] = invMass; this.particles[off+7] = 0.04; this.dirtyParticles.add(i);\n    }\n    setDistConstraint(i: number, a: number, b: number, len: number, comp: number) {\n        const off = i * 4; const uv = new Uint32Array(this.distConstraints.buffer); uv[off] = a; uv[off+1] = b; this.distConstraints[off+2] = len; this.distConstraints[off+3] = comp;\n    }\n    addAttachment(pIdx: number, aIdx: number, bIdx: number, t: number) {\n        const off = this.numAttachments * 4; const uv = new Uint32Array(this.attachments.buffer); uv[off] = pIdx; uv[off+1] = aIdx; uv[off+2] = bIdx; this.attachments[off+3] = t; this.numAttachments++;\n    }\n    syncGPU() { \n        this.device?.queue.writeBuffer(this.particleBuffer!, 0, this.particles);\n        this.device?.queue.writeBuffer(this.distConstraintBuffer!, 0, this.distConstraints);\n        this.device?.queue.writeBuffer(this.attachmentBuffer!, 0, this.attachments);\n    }\n\n    update(mousePos: THREE.Vector2) {\n        if (!this.ready || this.isReadingBack) return;\n        const dt = 1/60, subs = 12;\n        const fill = (ph: number) => {\n            const b = new ArrayBuffer(96), f = new Float32Array(b), u = new Uint32Array(b), i = new Int32Array(b);\n            f[0] = dt; f[1] = CONFIG.GRAVITY; u[2] = this.numParticles; u[3] = this.numDistConstraints; u[4] = subs; u[5] = ph; f[6] = mousePos.x; f[7] = mousePos.y; i[8] = this.activeRope ? this.activeRope.indices[this.activeRope.indices.length-1] : -1; u[9] = this.numAttachments; f[10] = CONFIG.VELOCITY_DAMPING; i[11] = this.pendulum ? this.pendulum.ballIdx : -1; u[12] = this.numObstacles;\n            return b;\n        };\n        this.device?.queue.writeBuffer(this.paramsBuffer0!, 0, fill(0)); this.device?.queue.writeBuffer(this.paramsBuffer1!, 0, fill(1));\n        const enc = this.device!.createCommandEncoder();\n        for (let s = 0; s < subs; s++) {\n            const p1 = enc.beginComputePass(); p1.setBindGroup(0, this.bindGroup0!); p1.setPipeline(this.pipelines.integrate!); p1.dispatchWorkgroups(Math.ceil(this.numParticles/64)); p1.end();\n            for (let i = 0; i < 6; i++) {\n                const d0 = enc.beginComputePass(); d0.setBindGroup(0, this.bindGroup0!); d0.setPipeline(this.pipelines.solveDistance!); d0.dispatchWorkgroups(Math.ceil(this.numDistConstraints/64)); d0.end();\n                const d1 = enc.beginComputePass(); d1.setBindGroup(0, this.bindGroup1!); d1.setPipeline(this.pipelines.solveDistance!); d1.dispatchWorkgroups(Math.ceil(this.numDistConstraints/64)); d1.end();\n                const at = enc.beginComputePass(); at.setBindGroup(0, this.bindGroup0!); at.setPipeline(this.pipelines.solveAttachments!); at.dispatchWorkgroups(Math.ceil(this.numAttachments/64)); at.end();\n            }\n            const c0 = enc.beginComputePass(); c0.setBindGroup(0, this.bindGroup0!); c0.setPipeline(this.pipelines.solveParticleCollisions!); c0.dispatchWorkgroups(Math.ceil(this.numParticles/64)); c0.end();\n            const c1 = enc.beginComputePass(); c1.setBindGroup(0, this.bindGroup0!); c1.setPipeline(this.pipelines.solveCollisions!); c1.dispatchWorkgroups(Math.ceil(this.numParticles/64)); c1.end();\n        }\n        enc.copyBufferToBuffer(this.particleBuffer!, 0, this.stagingBuffer!, 0, this.particles.byteLength);\n        this.device?.queue.submit([enc.finish()]);\n        this.readBackAndVisualize();\n    }\n\n    readBackAndVisualize() {\n        if (!this.stagingBuffer || this.isReadingBack) return;\n        this.isReadingBack = true;\n        this.stagingBuffer.mapAsync(GPUMapMode.READ).then(() => {\n            const data = new Float32Array(this.stagingBuffer!.getMappedRange());\n            const dirty = Array.from(this.dirtyParticles).map(i => ({i, data: this.particles.slice(i*8, i*8+8)}));\n            this.particles.set(data); dirty.forEach(b => this.particles.set(b.data, b.i*8)); this.dirtyParticles.clear();\n            this.stagingBuffer!.unmap(); this.isReadingBack = false; this.updateVisuals();\n        }).catch(() => this.isReadingBack = false);\n    }\n\n    updateVisuals() {\n        this.ropes.forEach(r => {\n            r.mesh.geometry.setDrawRange(0, r.indices.length); const attr = r.mesh.geometry.getAttribute('position');\n            for (let i = 0; i < r.indices.length; i++) attr.setXYZ(i, this.particles[r.indices[i]*8], this.particles[r.indices[i]*8+1], 0);\n            attr.needsUpdate = true;\n        });\n        this.balls.forEach(b => b.mesh.position.set(this.particles[b.idx*8], this.particles[b.idx*8+1], -0.1));\n        if (this.pendulum) {\n            const bPos = this.getParticlePos(this.pendulum.ballIdx), pPos = this.getParticlePos(this.pendulum.pivotIdx);\n            this.pendulum.mesh.position.set(bPos.x, bPos.y, -0.1);\n            const arm = this.pendulum.arm.geometry.getAttribute('position'); arm.setXYZ(0, pPos.x, pPos.y, -0.2); arm.setXYZ(1, bPos.x, bPos.y, -0.2); arm.needsUpdate = true;\n        }\n    }\n\n    getParticlePos(i: number) { return new THREE.Vector2(this.particles[i*8], this.particles[i*8+1]); }\n    findAnchor(pos: THREE.Vector2): any {\n        const bx=11.8, by=6.8, th=0.5;\n        if (Math.abs(pos.x)>bx-th || Math.abs(pos.y)>by-th) return { pos: pos.clone().clamp(new THREE.Vector2(-bx,-by), new THREE.Vector2(bx,by)), type: 'static' };\n        if (this.pendulum && pos.distanceTo(this.getParticlePos(this.pendulum.ballIdx)) < CONFIG.PENDULUM_RADIUS + th) return { pos, type: 'point', targetIdx: this.pendulum.ballIdx };\n        return null;\n    }\n\n    createRope(anchor: any) {\n        const idxA = this.allocParticle(), idxB = this.allocParticle(), indices = [idxA, idxB], cIdx = this.allocConstraint(), constraints = [cIdx];\n        this.setParticle(idxA, anchor.pos, anchor.type==='static'?0:1/CONFIG.ROPE_NODE_MASS); this.setParticle(idxB, anchor.pos, 1/CONFIG.ROPE_NODE_MASS);\n        if (anchor.type==='rope') this.addAttachment(idxA, anchor.aIdx, anchor.bIdx, anchor.t);\n        if (anchor.type==='point') this.addAttachment(idxA, anchor.targetIdx, anchor.targetIdx, 0);\n        this.setDistConstraint(cIdx, idxA, idxB, CONFIG.SEGMENT_LENGTH, CONFIG.ROPE_COMPLIANCE);\n        const geo = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(600), 3));\n        const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 }));\n        this.scene.add(line); const rope = { indices, constraintIndices: constraints, mesh: line, segments: 1, segmentLength: CONFIG.SEGMENT_LENGTH };\n        this.ropes.push(rope); this.activeRope = rope; this.syncGPU(); return rope;\n    }\n\n    pinActiveRope(rope: any, anchor: any) {\n        const last = rope.indices[rope.indices.length-1]; this.setParticle(last, anchor.pos, anchor.type==='static'?0:1/CONFIG.ROPE_NODE_MASS);\n        if (anchor.type==='rope') this.addAttachment(last, anchor.aIdx, anchor.bIdx, anchor.t);\n        if (anchor.type==='point') this.addAttachment(last, anchor.targetIdx, anchor.targetIdx, 0);\n        rope.mesh.material.color.set(0x00ffff); this.activeRope = null; this.syncGPU();\n    }\n\n    adjustRopeLength(rope: any, delta: number) {\n        const SEG = CONFIG.SEGMENT_LENGTH;\n        if (delta < 0 && rope.indices.length < 200) {\n            const tail = rope.indices[rope.indices.length-1], prev = rope.indices[rope.indices.length-2];\n            const newIdx = this.allocParticle(); this.setParticle(newIdx, this.getParticlePos(tail), 1/CONFIG.ROPE_NODE_MASS);\n            const lastC = rope.constraintIndices[rope.constraintIndices.length-1]; this.setDistConstraint(lastC, prev, newIdx, SEG, CONFIG.ROPE_COMPLIANCE);\n            const newC = this.allocConstraint(); rope.constraintIndices.push(newC); this.setDistConstraint(newC, newIdx, tail, SEG, CONFIG.ROPE_COMPLIANCE);\n            rope.indices.pop(); rope.indices.push(newIdx); rope.indices.push(tail); rope.segments++; this.syncGPU();\n        } else if (delta > 0 && rope.indices.length > 2) {\n            const tail = rope.indices.pop(), rem = rope.indices.pop(); rope.indices.push(tail); if (rem!==undefined) this.freeParticle(rem);\n            const remC = rope.constraintIndices.pop(); if (remC!==undefined) this.freeConstraint(remC);\n            const lastC = rope.constraintIndices[rope.constraintIndices.length-1], prev = rope.indices[rope.indices.length-2];\n            this.setDistConstraint(lastC, prev, tail, SEG, CONFIG.ROPE_COMPLIANCE); rope.segments--; this.syncGPU();\n        }\n    }\n\n    spawnBall(pos: THREE.Vector2) {\n        const idx = this.allocParticle(); if (idx===-1) return;\n        const rad = 0.3+Math.random()*0.5; this.setParticle(idx, pos, 0.5/(rad*rad)); this.particles[idx*8+7] = rad;\n        const mesh = new THREE.Mesh(new THREE.CircleGeometry(rad, 16), new THREE.MeshBasicMaterial({ color: 0x00ff88 }));\n        this.scene.add(mesh); this.balls.push({ idx, mesh }); this.syncGPU();\n    }\n}\n"
    },
    {
      "filename": "tsconfig.json",
      "content": "{\n  \"compilerOptions\": {\n    // Environment setup & latest features\n    \"lib\": [\"ESNext\", \"DOM\", \"DOM.Iterable\", \"WebWorker\"],\n    \"target\": \"ESNext\",\n    \"module\": \"Preserve\",\n    \"moduleDetection\": \"force\",\n    \"jsx\": \"react-jsx\",\n    \"allowJs\": true,\n\n    // Bundler mode\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"verbatimModuleSyntax\": true,\n    \"noEmit\": true,\n\n    // Best practices\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"noImplicitOverride\": true,\n\n    // Some stricter flags (disabled by default)\n    \"noUnusedLocals\": false,\n    \"noUnusedParameters\": false,\n    \"noPropertyAccessFromIndexSignature\": false\n  }\n}\n"
    },
    {
      "filename": "vite.config.js",
      "content": "import { defineConfig } from 'vite';\n\nexport default defineConfig({\n  server: {\n    port: 3000,\n    open: true\n  },\n  assetsInclude: ['**/*.wgsl'],\n  build: {\n    target: 'esnext'\n  },\n  optimizeDeps: {\n    esbuildOptions: {\n      target: 'esnext'\n    },\n    include: ['three']\n  },\n  resolve: {\n    alias: {\n      'three/webgpu': 'three/src/renderers/webgpu/WebGPURenderer.js'\n    }\n  }\n});"
    }
  ]
}