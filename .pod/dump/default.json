{
  "version": "0.0.111",
  "files": [
    {
      "filename": "README.md",
      "content": "# spider-web-physics\n\nTo install dependencies:\n\n```bash\nbun install\n```\n\nTo run:\n\n```bash\nbun run \n```\n\nThis project was created using `bun init` in bun v1.3.9. [Bun](https://bun.com) is a fast all-in-one JavaScript runtime.\n"
    },
    {
      "filename": "bun.lock",
      "content": "{\n  \"lockfileVersion\": 1,\n  \"configVersion\": 1,\n  \"workspaces\": {\n    \"\": {\n      \"name\": \"spider-web-physics\",\n      \"dependencies\": {\n        \"@webgpu/types\": \"^0.1.43\",\n        \"miniplex\": \"^2.0.0\",\n        \"react\": \"^19.2.4\",\n        \"react-dom\": \"^19.2.4\",\n        \"three\": \"^0.182.0\",\n      },\n      \"devDependencies\": {\n        \"@types/bun\": \"latest\",\n        \"@types/react\": \"^19.2.14\",\n        \"@types/react-dom\": \"^19.2.3\",\n        \"@types/three\": \"^0.182.0\",\n        \"typescript\": \"^5.3.0\",\n        \"vite\": \"^5.0.0\",\n      },\n      \"peerDependencies\": {\n        \"typescript\": \"^5\",\n      },\n    },\n  },\n  \"packages\": {\n    \"@dimforge/rapier3d-compat\": [\"@dimforge/rapier3d-compat@0.12.0\", \"\", {}, \"sha512-uekIGetywIgopfD97oDL5PfeezkFpNhwlzlaEYNOA0N6ghdsOvh/HYjSMek5Q2O1PYvRSDFcqFVJl4r4ZBwOow==\"],\n\n    \"@esbuild/aix-ppc64\": [\"@esbuild/aix-ppc64@0.21.5\", \"\", { \"os\": \"aix\", \"cpu\": \"ppc64\" }, \"sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==\"],\n\n    \"@esbuild/android-arm\": [\"@esbuild/android-arm@0.21.5\", \"\", { \"os\": \"android\", \"cpu\": \"arm\" }, \"sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==\"],\n\n    \"@esbuild/android-arm64\": [\"@esbuild/android-arm64@0.21.5\", \"\", { \"os\": \"android\", \"cpu\": \"arm64\" }, \"sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==\"],\n\n    \"@esbuild/android-x64\": [\"@esbuild/android-x64@0.21.5\", \"\", { \"os\": \"android\", \"cpu\": \"x64\" }, \"sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==\"],\n\n    \"@esbuild/darwin-arm64\": [\"@esbuild/darwin-arm64@0.21.5\", \"\", { \"os\": \"darwin\", \"cpu\": \"arm64\" }, \"sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==\"],\n\n    \"@esbuild/darwin-x64\": [\"@esbuild/darwin-x64@0.21.5\", \"\", { \"os\": \"darwin\", \"cpu\": \"x64\" }, \"sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==\"],\n\n    \"@esbuild/freebsd-arm64\": [\"@esbuild/freebsd-arm64@0.21.5\", \"\", { \"os\": \"freebsd\", \"cpu\": \"arm64\" }, \"sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==\"],\n\n    \"@esbuild/freebsd-x64\": [\"@esbuild/freebsd-x64@0.21.5\", \"\", { \"os\": \"freebsd\", \"cpu\": \"x64\" }, \"sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==\"],\n\n    \"@esbuild/linux-arm\": [\"@esbuild/linux-arm@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"arm\" }, \"sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==\"],\n\n    \"@esbuild/linux-arm64\": [\"@esbuild/linux-arm64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"arm64\" }, \"sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==\"],\n\n    \"@esbuild/linux-ia32\": [\"@esbuild/linux-ia32@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"ia32\" }, \"sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==\"],\n\n    \"@esbuild/linux-loong64\": [\"@esbuild/linux-loong64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==\"],\n\n    \"@esbuild/linux-mips64el\": [\"@esbuild/linux-mips64el@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==\"],\n\n    \"@esbuild/linux-ppc64\": [\"@esbuild/linux-ppc64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"ppc64\" }, \"sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==\"],\n\n    \"@esbuild/linux-riscv64\": [\"@esbuild/linux-riscv64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==\"],\n\n    \"@esbuild/linux-s390x\": [\"@esbuild/linux-s390x@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"s390x\" }, \"sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==\"],\n\n    \"@esbuild/linux-x64\": [\"@esbuild/linux-x64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"x64\" }, \"sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==\"],\n\n    \"@esbuild/netbsd-x64\": [\"@esbuild/netbsd-x64@0.21.5\", \"\", { \"os\": \"none\", \"cpu\": \"x64\" }, \"sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==\"],\n\n    \"@esbuild/openbsd-x64\": [\"@esbuild/openbsd-x64@0.21.5\", \"\", { \"os\": \"openbsd\", \"cpu\": \"x64\" }, \"sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==\"],\n\n    \"@esbuild/sunos-x64\": [\"@esbuild/sunos-x64@0.21.5\", \"\", { \"os\": \"sunos\", \"cpu\": \"x64\" }, \"sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==\"],\n\n    \"@esbuild/win32-arm64\": [\"@esbuild/win32-arm64@0.21.5\", \"\", { \"os\": \"win32\", \"cpu\": \"arm64\" }, \"sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==\"],\n\n    \"@esbuild/win32-ia32\": [\"@esbuild/win32-ia32@0.21.5\", \"\", { \"os\": \"win32\", \"cpu\": \"ia32\" }, \"sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==\"],\n\n    \"@esbuild/win32-x64\": [\"@esbuild/win32-x64@0.21.5\", \"\", { \"os\": \"win32\", \"cpu\": \"x64\" }, \"sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==\"],\n\n    \"@hmans/id\": [\"@hmans/id@0.0.1\", \"\", {}, \"sha512-2BxHxZziST8F0P5Dt+UuttF2lwCaKK7QFR814PwEp708l6dm86pjWJAFr7BKyAGu27mRpYcghvCAUAucNdsCdw==\"],\n\n    \"@hmans/queue\": [\"@hmans/queue@0.0.1\", \"\", {}, \"sha512-Mm8oQRFRoiEYQ3QD9CD14DTaShd21nzNrUFyBhFxy+TduKf2PdMRfHHx7lDvEpbODGNlj+e8mcWGj/YjWmC3Bw==\"],\n\n    \"@miniplex/bucket\": [\"@miniplex/bucket@2.0.0\", \"\", { \"dependencies\": { \"eventery\": \"^0.0.4\" } }, \"sha512-jdAW0vG0tLel0dD0lyQqkQ4g4G9CscbVtenu35jB48fnVK3zmfFmQKIxXHsUvFs4KAN44UESAgaVOroTetFSRw==\"],\n\n    \"@rollup/rollup-android-arm-eabi\": [\"@rollup/rollup-android-arm-eabi@4.57.1\", \"\", { \"os\": \"android\", \"cpu\": \"arm\" }, \"sha512-A6ehUVSiSaaliTxai040ZpZ2zTevHYbvu/lDoeAteHI8QnaosIzm4qwtezfRg1jOYaUmnzLX1AOD6Z+UJjtifg==\"],\n\n    \"@rollup/rollup-android-arm64\": [\"@rollup/rollup-android-arm64@4.57.1\", \"\", { \"os\": \"android\", \"cpu\": \"arm64\" }, \"sha512-dQaAddCY9YgkFHZcFNS/606Exo8vcLHwArFZ7vxXq4rigo2bb494/xKMMwRRQW6ug7Js6yXmBZhSBRuBvCCQ3w==\"],\n\n    \"@rollup/rollup-darwin-arm64\": [\"@rollup/rollup-darwin-arm64@4.57.1\", \"\", { \"os\": \"darwin\", \"cpu\": \"arm64\" }, \"sha512-crNPrwJOrRxagUYeMn/DZwqN88SDmwaJ8Cvi/TN1HnWBU7GwknckyosC2gd0IqYRsHDEnXf328o9/HC6OkPgOg==\"],\n\n    \"@rollup/rollup-darwin-x64\": [\"@rollup/rollup-darwin-x64@4.57.1\", \"\", { \"os\": \"darwin\", \"cpu\": \"x64\" }, \"sha512-Ji8g8ChVbKrhFtig5QBV7iMaJrGtpHelkB3lsaKzadFBe58gmjfGXAOfI5FV0lYMH8wiqsxKQ1C9B0YTRXVy4w==\"],\n\n    \"@rollup/rollup-freebsd-arm64\": [\"@rollup/rollup-freebsd-arm64@4.57.1\", \"\", { \"os\": \"freebsd\", \"cpu\": \"arm64\" }, \"sha512-R+/WwhsjmwodAcz65guCGFRkMb4gKWTcIeLy60JJQbXrJ97BOXHxnkPFrP+YwFlaS0m+uWJTstrUA9o+UchFug==\"],\n\n    \"@rollup/rollup-freebsd-x64\": [\"@rollup/rollup-freebsd-x64@4.57.1\", \"\", { \"os\": \"freebsd\", \"cpu\": \"x64\" }, \"sha512-IEQTCHeiTOnAUC3IDQdzRAGj3jOAYNr9kBguI7MQAAZK3caezRrg0GxAb6Hchg4lxdZEI5Oq3iov/w/hnFWY9Q==\"],\n\n    \"@rollup/rollup-linux-arm-gnueabihf\": [\"@rollup/rollup-linux-arm-gnueabihf@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"arm\" }, \"sha512-F8sWbhZ7tyuEfsmOxwc2giKDQzN3+kuBLPwwZGyVkLlKGdV1nvnNwYD0fKQ8+XS6hp9nY7B+ZeK01EBUE7aHaw==\"],\n\n    \"@rollup/rollup-linux-arm-musleabihf\": [\"@rollup/rollup-linux-arm-musleabihf@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"arm\" }, \"sha512-rGfNUfn0GIeXtBP1wL5MnzSj98+PZe/AXaGBCRmT0ts80lU5CATYGxXukeTX39XBKsxzFpEeK+Mrp9faXOlmrw==\"],\n\n    \"@rollup/rollup-linux-arm64-gnu\": [\"@rollup/rollup-linux-arm64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"arm64\" }, \"sha512-MMtej3YHWeg/0klK2Qodf3yrNzz6CGjo2UntLvk2RSPlhzgLvYEB3frRvbEF2wRKh1Z2fDIg9KRPe1fawv7C+g==\"],\n\n    \"@rollup/rollup-linux-arm64-musl\": [\"@rollup/rollup-linux-arm64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"arm64\" }, \"sha512-1a/qhaaOXhqXGpMFMET9VqwZakkljWHLmZOX48R0I/YLbhdxr1m4gtG1Hq7++VhVUmf+L3sTAf9op4JlhQ5u1Q==\"],\n\n    \"@rollup/rollup-linux-loong64-gnu\": [\"@rollup/rollup-linux-loong64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-QWO6RQTZ/cqYtJMtxhkRkidoNGXc7ERPbZN7dVW5SdURuLeVU7lwKMpo18XdcmpWYd0qsP1bwKPf7DNSUinhvA==\"],\n\n    \"@rollup/rollup-linux-loong64-musl\": [\"@rollup/rollup-linux-loong64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-xpObYIf+8gprgWaPP32xiN5RVTi/s5FCR+XMXSKmhfoJjrpRAjCuuqQXyxUa/eJTdAE6eJ+KDKaoEqjZQxh3Gw==\"],\n\n    \"@rollup/rollup-linux-ppc64-gnu\": [\"@rollup/rollup-linux-ppc64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"ppc64\" }, \"sha512-4BrCgrpZo4hvzMDKRqEaW1zeecScDCR+2nZ86ATLhAoJ5FQ+lbHVD3ttKe74/c7tNT9c6F2viwB3ufwp01Oh2w==\"],\n\n    \"@rollup/rollup-linux-ppc64-musl\": [\"@rollup/rollup-linux-ppc64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"ppc64\" }, \"sha512-NOlUuzesGauESAyEYFSe3QTUguL+lvrN1HtwEEsU2rOwdUDeTMJdO5dUYl/2hKf9jWydJrO9OL/XSSf65R5+Xw==\"],\n\n    \"@rollup/rollup-linux-riscv64-gnu\": [\"@rollup/rollup-linux-riscv64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-ptA88htVp0AwUUqhVghwDIKlvJMD/fmL/wrQj99PRHFRAG6Z5nbWoWG4o81Nt9FT+IuqUQi+L31ZKAFeJ5Is+A==\"],\n\n    \"@rollup/rollup-linux-riscv64-musl\": [\"@rollup/rollup-linux-riscv64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-S51t7aMMTNdmAMPpBg7OOsTdn4tySRQvklmL3RpDRyknk87+Sp3xaumlatU+ppQ+5raY7sSTcC2beGgvhENfuw==\"],\n\n    \"@rollup/rollup-linux-s390x-gnu\": [\"@rollup/rollup-linux-s390x-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"s390x\" }, \"sha512-Bl00OFnVFkL82FHbEqy3k5CUCKH6OEJL54KCyx2oqsmZnFTR8IoNqBF+mjQVcRCT5sB6yOvK8A37LNm/kPJiZg==\"],\n\n    \"@rollup/rollup-linux-x64-gnu\": [\"@rollup/rollup-linux-x64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"x64\" }, \"sha512-ABca4ceT4N+Tv/GtotnWAeXZUZuM/9AQyCyKYyKnpk4yoA7QIAuBt6Hkgpw8kActYlew2mvckXkvx0FfoInnLg==\"],\n\n    \"@rollup/rollup-linux-x64-musl\": [\"@rollup/rollup-linux-x64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"x64\" }, \"sha512-HFps0JeGtuOR2convgRRkHCekD7j+gdAuXM+/i6kGzQtFhlCtQkpwtNzkNj6QhCDp7DRJ7+qC/1Vg2jt5iSOFw==\"],\n\n    \"@rollup/rollup-openbsd-x64\": [\"@rollup/rollup-openbsd-x64@4.57.1\", \"\", { \"os\": \"openbsd\", \"cpu\": \"x64\" }, \"sha512-H+hXEv9gdVQuDTgnqD+SQffoWoc0Of59AStSzTEj/feWTBAnSfSD3+Dql1ZruJQxmykT/JVY0dE8Ka7z0DH1hw==\"],\n\n    \"@rollup/rollup-openharmony-arm64\": [\"@rollup/rollup-openharmony-arm64@4.57.1\", \"\", { \"os\": \"none\", \"cpu\": \"arm64\" }, \"sha512-4wYoDpNg6o/oPximyc/NG+mYUejZrCU2q+2w6YZqrAs2UcNUChIZXjtafAiiZSUc7On8v5NyNj34Kzj/Ltk6dQ==\"],\n\n    \"@rollup/rollup-win32-arm64-msvc\": [\"@rollup/rollup-win32-arm64-msvc@4.57.1\", \"\", { \"os\": \"win32\", \"cpu\": \"arm64\" }, \"sha512-O54mtsV/6LW3P8qdTcamQmuC990HDfR71lo44oZMZlXU4tzLrbvTii87Ni9opq60ds0YzuAlEr/GNwuNluZyMQ==\"],\n\n    \"@rollup/rollup-win32-ia32-msvc\": [\"@rollup/rollup-win32-ia32-msvc@4.57.1\", \"\", { \"os\": \"win32\", \"cpu\": \"ia32\" }, \"sha512-P3dLS+IerxCT/7D2q2FYcRdWRl22dNbrbBEtxdWhXrfIMPP9lQhb5h4Du04mdl5Woq05jVCDPCMF7Ub0NAjIew==\"],\n\n    \"@rollup/rollup-win32-x64-gnu\": [\"@rollup/rollup-win32-x64-gnu@4.57.1\", \"\", { \"os\": \"win32\", \"cpu\": \"x64\" }, \"sha512-VMBH2eOOaKGtIJYleXsi2B8CPVADrh+TyNxJ4mWPnKfLB/DBUmzW+5m1xUrcwWoMfSLagIRpjUFeW5CO5hyciQ==\"],\n\n    \"@rollup/rollup-win32-x64-msvc\": [\"@rollup/rollup-win32-x64-msvc@4.57.1\", \"\", { \"os\": \"win32\", \"cpu\": \"x64\" }, \"sha512-mxRFDdHIWRxg3UfIIAwCm6NzvxG0jDX/wBN6KsQFTvKFqqg9vTrWUE68qEjHt19A5wwx5X5aUi2zuZT7YR0jrA==\"],\n\n    \"@tweenjs/tween.js\": [\"@tweenjs/tween.js@23.1.3\", \"\", {}, \"sha512-vJmvvwFxYuGnF2axRtPYocag6Clbb5YS7kLL+SO/TeVFzHqDIWrNKYtcsPMibjDx9O+bu+psAy9NKfWklassUA==\"],\n\n    \"@types/bun\": [\"@types/bun@1.3.9\", \"\", { \"dependencies\": { \"bun-types\": \"1.3.9\" } }, \"sha512-KQ571yULOdWJiMH+RIWIOZ7B2RXQGpL1YQrBtLIV3FqDcCu6FsbFUBwhdKUlCKUpS3PJDsHlJ1QKlpxoVR+xtw==\"],\n\n    \"@types/estree\": [\"@types/estree@1.0.8\", \"\", {}, \"sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==\"],\n\n    \"@types/node\": [\"@types/node@25.2.3\", \"\", { \"dependencies\": { \"undici-types\": \"~7.16.0\" } }, \"sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==\"],\n\n    \"@types/react\": [\"@types/react@19.2.14\", \"\", { \"dependencies\": { \"csstype\": \"^3.2.2\" } }, \"sha512-ilcTH/UniCkMdtexkoCN0bI7pMcJDvmQFPvuPvmEaYA/NSfFTAgdUSLAoVjaRJm7+6PvcM+q1zYOwS4wTYMF9w==\"],\n\n    \"@types/react-dom\": [\"@types/react-dom@19.2.3\", \"\", { \"peerDependencies\": { \"@types/react\": \"^19.2.0\" } }, \"sha512-jp2L/eY6fn+KgVVQAOqYItbF0VY/YApe5Mz2F0aykSO8gx31bYCZyvSeYxCHKvzHG5eZjc+zyaS5BrBWya2+kQ==\"],\n\n    \"@types/stats.js\": [\"@types/stats.js@0.17.4\", \"\", {}, \"sha512-jIBvWWShCvlBqBNIZt0KAshWpvSjhkwkEu4ZUcASoAvhmrgAUI2t1dXrjSL4xXVLB4FznPrIsX3nKXFl/Dt4vA==\"],\n\n    \"@types/three\": [\"@types/three@0.182.0\", \"\", { \"dependencies\": { \"@dimforge/rapier3d-compat\": \"~0.12.0\", \"@tweenjs/tween.js\": \"~23.1.3\", \"@types/stats.js\": \"*\", \"@types/webxr\": \">=0.5.17\", \"@webgpu/types\": \"*\", \"fflate\": \"~0.8.2\", \"meshoptimizer\": \"~0.22.0\" } }, \"sha512-WByN9V3Sbwbe2OkWuSGyoqQO8Du6yhYaXtXLoA5FkKTUJorZ+yOHBZ35zUUPQXlAKABZmbYp5oAqpA4RBjtJ/Q==\"],\n\n    \"@types/webxr\": [\"@types/webxr@0.5.24\", \"\", {}, \"sha512-h8fgEd/DpoS9CBrjEQXR+dIDraopAEfu4wYVNY2tEPwk60stPWhvZMf4Foo5FakuQ7HFZoa8WceaWFervK2Ovg==\"],\n\n    \"@webgpu/types\": [\"@webgpu/types@0.1.69\", \"\", {}, \"sha512-RPmm6kgRbI8e98zSD3RVACvnuktIja5+yLgDAkTmxLr90BEwdTXRQWNLF3ETTTyH/8mKhznZuN5AveXYFEsMGQ==\"],\n\n    \"bun-types\": [\"bun-types@1.3.9\", \"\", { \"dependencies\": { \"@types/node\": \"*\" } }, \"sha512-+UBWWOakIP4Tswh0Bt0QD0alpTY8cb5hvgiYeWCMet9YukHbzuruIEeXC2D7nMJPB12kbh8C7XJykSexEqGKJg==\"],\n\n    \"csstype\": [\"csstype@3.2.3\", \"\", {}, \"sha512-z1HGKcYy2xA8AGQfwrn0PAy+PB7X/GSj3UVJW9qKyn43xWa+gl5nXmU4qqLMRzWVLFC8KusUX8T/0kCiOYpAIQ==\"],\n\n    \"esbuild\": [\"esbuild@0.21.5\", \"\", { \"optionalDependencies\": { \"@esbuild/aix-ppc64\": \"0.21.5\", \"@esbuild/android-arm\": \"0.21.5\", \"@esbuild/android-arm64\": \"0.21.5\", \"@esbuild/android-x64\": \"0.21.5\", \"@esbuild/darwin-arm64\": \"0.21.5\", \"@esbuild/darwin-x64\": \"0.21.5\", \"@esbuild/freebsd-arm64\": \"0.21.5\", \"@esbuild/freebsd-x64\": \"0.21.5\", \"@esbuild/linux-arm\": \"0.21.5\", \"@esbuild/linux-arm64\": \"0.21.5\", \"@esbuild/linux-ia32\": \"0.21.5\", \"@esbuild/linux-loong64\": \"0.21.5\", \"@esbuild/linux-mips64el\": \"0.21.5\", \"@esbuild/linux-ppc64\": \"0.21.5\", \"@esbuild/linux-riscv64\": \"0.21.5\", \"@esbuild/linux-s390x\": \"0.21.5\", \"@esbuild/linux-x64\": \"0.21.5\", \"@esbuild/netbsd-x64\": \"0.21.5\", \"@esbuild/openbsd-x64\": \"0.21.5\", \"@esbuild/sunos-x64\": \"0.21.5\", \"@esbuild/win32-arm64\": \"0.21.5\", \"@esbuild/win32-ia32\": \"0.21.5\", \"@esbuild/win32-x64\": \"0.21.5\" }, \"bin\": { \"esbuild\": \"bin/esbuild\" } }, \"sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==\"],\n\n    \"eventery\": [\"eventery@0.0.4\", \"\", {}, \"sha512-rQbXJG8WX9z2cm3IJadkSUZLWFXuwGMIJ40oWyB23DhVb1e92T7Jx3qF0UwtgHI7D4VZzVswbZ7MXfW88cFF4Q==\"],\n\n    \"fflate\": [\"fflate@0.8.2\", \"\", {}, \"sha512-cPJU47OaAoCbg0pBvzsgpTPhmhqI5eJjh/JIu8tPj5q+T7iLvW/JAYUqmE7KOB4R1ZyEhzBaIQpQpardBF5z8A==\"],\n\n    \"fsevents\": [\"fsevents@2.3.3\", \"\", { \"os\": \"darwin\" }, \"sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==\"],\n\n    \"meshoptimizer\": [\"meshoptimizer@0.22.0\", \"\", {}, \"sha512-IebiK79sqIy+E4EgOr+CAw+Ke8hAspXKzBd0JdgEmPHiAwmvEj2S4h1rfvo+o/BnfEYd/jAOg5IeeIjzlzSnDg==\"],\n\n    \"miniplex\": [\"miniplex@2.0.0\", \"\", { \"dependencies\": { \"@hmans/id\": \"^0.0.1\", \"@hmans/queue\": \"^0.0.1\", \"@miniplex/bucket\": \"2.0.0\" } }, \"sha512-pJlxmlPf5Qyx12amgOCyRE6Lzw28ct2G0lF9xn7/xudLtA/xDOUnCIU2xOxCk8GkjePYctcNpjmFshJp/Ht66A==\"],\n\n    \"nanoid\": [\"nanoid@3.3.11\", \"\", { \"bin\": { \"nanoid\": \"bin/nanoid.cjs\" } }, \"sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==\"],\n\n    \"picocolors\": [\"picocolors@1.1.1\", \"\", {}, \"sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==\"],\n\n    \"postcss\": [\"postcss@8.5.6\", \"\", { \"dependencies\": { \"nanoid\": \"^3.3.11\", \"picocolors\": \"^1.1.1\", \"source-map-js\": \"^1.2.1\" } }, \"sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==\"],\n\n    \"react\": [\"react@19.2.4\", \"\", {}, \"sha512-9nfp2hYpCwOjAN+8TZFGhtWEwgvWHXqESH8qT89AT/lWklpLON22Lc8pEtnpsZz7VmawabSU0gCjnj8aC0euHQ==\"],\n\n    \"react-dom\": [\"react-dom@19.2.4\", \"\", { \"dependencies\": { \"scheduler\": \"^0.27.0\" }, \"peerDependencies\": { \"react\": \"^19.2.4\" } }, \"sha512-AXJdLo8kgMbimY95O2aKQqsz2iWi9jMgKJhRBAxECE4IFxfcazB2LmzloIoibJI3C12IlY20+KFaLv+71bUJeQ==\"],\n\n    \"rollup\": [\"rollup@4.57.1\", \"\", { \"dependencies\": { \"@types/estree\": \"1.0.8\" }, \"optionalDependencies\": { \"@rollup/rollup-android-arm-eabi\": \"4.57.1\", \"@rollup/rollup-android-arm64\": \"4.57.1\", \"@rollup/rollup-darwin-arm64\": \"4.57.1\", \"@rollup/rollup-darwin-x64\": \"4.57.1\", \"@rollup/rollup-freebsd-arm64\": \"4.57.1\", \"@rollup/rollup-freebsd-x64\": \"4.57.1\", \"@rollup/rollup-linux-arm-gnueabihf\": \"4.57.1\", \"@rollup/rollup-linux-arm-musleabihf\": \"4.57.1\", \"@rollup/rollup-linux-arm64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-arm64-musl\": \"4.57.1\", \"@rollup/rollup-linux-loong64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-loong64-musl\": \"4.57.1\", \"@rollup/rollup-linux-ppc64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-ppc64-musl\": \"4.57.1\", \"@rollup/rollup-linux-riscv64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-riscv64-musl\": \"4.57.1\", \"@rollup/rollup-linux-s390x-gnu\": \"4.57.1\", \"@rollup/rollup-linux-x64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-x64-musl\": \"4.57.1\", \"@rollup/rollup-openbsd-x64\": \"4.57.1\", \"@rollup/rollup-openharmony-arm64\": \"4.57.1\", \"@rollup/rollup-win32-arm64-msvc\": \"4.57.1\", \"@rollup/rollup-win32-ia32-msvc\": \"4.57.1\", \"@rollup/rollup-win32-x64-gnu\": \"4.57.1\", \"@rollup/rollup-win32-x64-msvc\": \"4.57.1\", \"fsevents\": \"~2.3.2\" }, \"bin\": { \"rollup\": \"dist/bin/rollup\" } }, \"sha512-oQL6lgK3e2QZeQ7gcgIkS2YZPg5slw37hYufJ3edKlfQSGGm8ICoxswK15ntSzF/a8+h7ekRy7k7oWc3BQ7y8A==\"],\n\n    \"scheduler\": [\"scheduler@0.27.0\", \"\", {}, \"sha512-eNv+WrVbKu1f3vbYJT/xtiF5syA5HPIMtf9IgY/nKg0sWqzAUEvqY/xm7OcZc/qafLx/iO9FgOmeSAp4v5ti/Q==\"],\n\n    \"source-map-js\": [\"source-map-js@1.2.1\", \"\", {}, \"sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==\"],\n\n    \"three\": [\"three@0.182.0\", \"\", {}, \"sha512-GbHabT+Irv+ihI1/f5kIIsZ+Ef9Sl5A1Y7imvS5RQjWgtTPfPnZ43JmlYI7NtCRDK9zir20lQpfg8/9Yd02OvQ==\"],\n\n    \"typescript\": [\"typescript@5.9.3\", \"\", { \"bin\": { \"tsc\": \"bin/tsc\", \"tsserver\": \"bin/tsserver\" } }, \"sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==\"],\n\n    \"undici-types\": [\"undici-types@7.16.0\", \"\", {}, \"sha512-Zz+aZWSj8LE6zoxD+xrjh4VfkIG8Ya6LvYkZqtUQGJPZjYl53ypCaUwWqo7eI0x66KBGeRo+mlBEkMSeSZ38Nw==\"],\n\n    \"vite\": [\"vite@5.4.21\", \"\", { \"dependencies\": { \"esbuild\": \"^0.21.3\", \"postcss\": \"^8.4.43\", \"rollup\": \"^4.20.0\" }, \"optionalDependencies\": { \"fsevents\": \"~2.3.3\" }, \"peerDependencies\": { \"@types/node\": \"^18.0.0 || >=20.0.0\", \"less\": \"*\", \"lightningcss\": \"^1.21.0\", \"sass\": \"*\", \"sass-embedded\": \"*\", \"stylus\": \"*\", \"sugarss\": \"*\", \"terser\": \"^5.4.0\" }, \"optionalPeers\": [\"@types/node\", \"less\", \"lightningcss\", \"sass\", \"sass-embedded\", \"stylus\", \"sugarss\", \"terser\"], \"bin\": { \"vite\": \"bin/vite.js\" } }, \"sha512-o5a9xKjbtuhY6Bi5S3+HvbRERmouabWbyUcpXXUA1u+GNUKoROi9byOJ8M0nHbHYHkYICiMlqxkg1KkYmm25Sw==\"],\n  }\n}\n"
    },
    {
      "filename": "docs/architecture.md",
      "content": "# Web-Builder 2D Architecture\n\n## 1. Technical Stack\n- **Renderer:** Three.js `WebGPURenderer` (rendering and GPU state management).\n- **Physics Engine:** Custom WebGPU Compute Shaders based on **Position Based Dynamics (PBD)**.\n- **State Management (ECS):** `miniplex` for entity management, level structure, and CPU-side logic.\n- **Editor Engine:** Gizmo and Tool management via React + ECS interactions.\n- **Frontend:** React for the Editor UI and tool management.\n\n## 2. Core Architectural Pillars\n\n### A. The GPU / ECS Hybrid Flow\n1. **React UI:** User selects tools (Build, Create, Edit).\n2. **Miniplex World:** Interactions create or modify **Entities**. \n   - *Example Entity:* `{ transform, sdfCollider, renderable }`.\n3. **Sync Systems:** \n   - **Static Sync:** Updates GPU `Obstacles` with Transform matrices and SDF params.\n   - **Dynamic Sync:** Reads back particle positions; updates ECS `Transform` and UI `Object List`.\n   - **Property Sync:** UI edits directly modify ECS components, triggering buffer updates.\n4. **Solver:** The Compute Shader runs PBD iterations (Integrate -> Solve Constraints -> Solve Collisions).\n\n### B. Collision & Shapes\n- **Analytical SDFs:** Initial support for Circles and Boxes (fast, exact).\n- **Particle Clusters:** Complex dynamic objects are built from groups of particles held together by rigid distance/angle constraints.\n- **Texture SDFs (Planned):** For static level geometry, allowing complex hand-drawn environments processed via distance field textures.\n\n### C. Friction & Materials\n- **PBD Friction:** Implemented by projecting `oldPos` toward the current `pos` along the collision tangent, effectively reducing velocity components parallel to surfaces.\n- **Material Properties:** Entities will hold `friction`, `elasticity`, and `mass` components, which are packed into GPU buffers per-object.\n\n### D. Constraints & Motors\n- **Constraints:** Distance (ropes/stiffness), Angle (bending/rigidity), and Weld (rigid attachments).\n- **Motors:** \n  - **Motor Pins:** A special constraint type that applies a target angular velocity to a particle cluster relative to a pivot.\n  - **Linear Motors:** Adjustable `rest_length` over time (used in the rope spooling logic).\n\n## 3. Communication Diagram\n```mermaid\ngraph TD\n    A[React UI] -->|Commands| B(Miniplex World)\n    B -->|System: ObstacleSync| C[WebGPU Storage Buffers]\n    C -->|Compute Shader| D[GPU Physics Solver]\n    D -->|ReadBack| E(System: PhysicsSync)\n    E -->|Update Components| B\n    B -->|System: Render| F[Three.js Scene]\n```\n\n## 4. Remaining Considerations / To-Do\n- **Spatial Partitioning:** Implementation of a Spatial Hash Grid on GPU if static complexity exceeds analytical limits.\n- **Level Serialization:** Standardizing the JSON schema for ECS entity export/import.\n- **Substepping Optimization:** Balancing GPU iterations vs. CPU readback latency for maximum stability."
    },
    {
      "filename": "docs/editor_spec.md",
      "content": "# Pajonk Level Editor Specification\n\n## 1. UI Layout & Functional Areas\n\n### 1.1 Top Menu\n- **Level:** \n  - `Create New`: Clears ECS world and GPU buffers.\n  - `Save`: Serializes ECS entities (filtered by 'persistent' tag) to JSON.\n  - `Load`: Deserializes JSON and recreates entities/GPU buffers.\n- **Mode:**\n  - `Editor`: Physics paused (or selective spooling), gizmos active, selection enabled.\n  - `Player`: Physics running, gizmos hidden, UI collapsed to minimal overlay.\n- **View:** Toggles (Checkboxes) for visibility of side panels:\n  - `Object List`, `Object Properties`, `Object Palette`.\n\n### 1.2 Object List (Panel)\n- Hierarchical or flat list of all active entities.\n- **Filters:** [All, Static, Dynamic, Rope, Special].\n- **Search:** Fuzzy search by entity name/ID.\n- **Actions:** Hide/Show (eye icon), Lock (prevent selection), Delete.\n\n### 1.3 Object Palette (Panel)\n- List of \"Blueprints\" for drag-and-drop or click-to-place:\n  - **Statics:** Box, Circle, Rounded Box.\n  - **Dynamics:** Physics-active Circle, Box.\n  - **Kinematics:** Plank (rigid bar), Heavy Ball, Bridge Segment.\n  - **Special:** Player Start, Goal, Wind Source.\n\n### 1.4 Object Properties (Panel)\n- Context-aware editor based on current selection.\n- **Common:** Position (X, Y), Name, Attachable (Boolean).\n- **Geometry:** Width, Height, Radius, Rotation (Degrees/Radians).\n- **Physics:** Mass, Friction, Elasticity (Restitution).\n- **Visual:** Color (Hex/Picker), Texture, Opacity.\n\n### 1.5 Toolbar\n- **Simulation:** [Stop, Play, Step-Frame].\n- **Tools:**\n  - `Select`: Basic click/box selection.\n  - `Move/Translate`: GRS Gizmo or direct drag.\n  - `Rotate`: Rotation ring gizmo.\n  - `Scale`: Axis-aligned scale gizmo (Static/Dynamic only).\n  - `Build Line`: Manual/Auto rope spooling tool.\n\n## 2. Object Type Definitions\n\n| Type | Physics Logic | Transformations | Notes |\n| :--- | :--- | :--- | :--- |\n| **Static** | Analytical SDF in GPU `Obstacles` buffer. | Pos, Rotate, Scale | Used for level geometry/walls. |\n| **Dynamic** | Particle-based (Single or Group). | Pos, Rotate, Scale | Basic physics shapes. |\n| **Kinematic** | Predefined particle clusters + rigid constraints. | Pos, Rotate | Fixed internal structure (e.g. Planks). |\n| **Rope** | Linked particle chain. | Control points | Spooled via tool or logic. |\n| **Player** | Complex Kinematic (Pajonk Zyzio). | Pos, Input-driven | Specialized PBD logic for legs/sticking. |\n\n## 3. Technical Implementation Details\n\n### 3.1 Attachable Property\n- A component `isAttachable` in ECS.\n- When the Rope Tool is active, `findAnchor` performs an intersection test only against entities with this component.\n- On GPU, this may be packed into a bitmask in the `Obstacle` or `Particle` struct.\n\n### 3.2 Transform Matrices (SDF Objects)\n- For rotated/scaled Statics, the GPU shader will receive an `inverseTransform` matrix.\n- Collision check: `Point_Local = InverseTransform * Point_World`.\n- The SDF calculation is then performed in local space, ensuring rotation and non-uniform scaling work perfectly.\n\n### 3.3 Kinematic Groups\n- Kinematics (like Planks) are instantiated as a set of particles.\n- **Weld Constraints:** Maintain 0-distance and fixed relative angles between nodes.\n- **Rotation:** Applying a rotation to a Kinematic object in the editor rotates the entire cluster's initial local coordinates before syncing to GPU."
    },
    {
      "filename": "index.html",
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Web-Builder Editor</title>\n    <style>\n        body { margin: 0; overflow: hidden; background: #000; color: white; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }\n        #root { width: 100vw; height: 100vh; }\n    </style>\n</head>\n<body>\n    <div id=\"root\"></div>\n    <script type=\"module\" src=\"/src/main.tsx\"></script>\n</body>\n</html>"
    },
    {
      "filename": "mvp.md",
      "content": "Oto definicja MVP dla Twojej gry „Web-Builder 2D” na WebGPU:\n1. Świat Gry (Środowisko)\nProstokątne „Akwarium”: Granice ekranu stanowią twarde kolizje.\nWektor Wiatru: Globalna zmienna uniform vec2 windForce, która co klatkę dodaje siłę do każdego wolnego węzła.\n2. Fizyka (Compute Shader / PBD)\nUżyjemy Position Based Dynamics, bo jest najbardziej stabilne dla sznurków i WebGPU.\nBufor Punktów (Particles): Każdy punkt ma: position, old_position, mass (0 dla punktów przytwierdzonych).\nBufor Wiązań (Constraints): Indeks punktu A, indeks punktu B, rest_length (długość spoczynkowa).\nKrok Fizyki:\nAplikacja wiatru i grawitacji (nowa pozycja).\nRozwiązanie wiązań (pętla iteracyjna – pociąganie punktów ku sobie, by zachować rest_length).\nKolizja ze ścianami (jeśli pos.x < 0, to pos.x = 0).\n3. Pająk (Gracz) – Logika i Sterowanie\nPająk jest specjalnym „super-węzłem” w systemie fizycznym. Ma dwa stany:\nA. Stan: Chodzenie (On Wall/Ceiling)\nPająk jest „przyklejony” do ściany (jego masa w shaderze = 0, lub ignorujemy siły zewnętrzne).\nRuch: Zmieniamy jego współrzędne bezpośrednio na podstawie klawiszy (L/P/G/D).\nJump: Odlepia pająka od ściany, nadaje mu prędkość początkową i zmienia stan na IN_AIR.\nB. Stan: Wiszenie/Lot (In Air)\nPająk staje się zwykłym punktem fizycznym podlegającym grawitacji i wiatrowi.\nWytwarzanie liny: Jeśli pająk skacze, automatycznie tworzy się pierwsze wiązanie między punktem na ścianie (kotwicą) a pająkiem.\n4. Mechanika Liny (Dynamiczne Wiązania)\nTo jest serce gry. Musisz zarządzać listą węzłów liny, którą pająk „rozwija”.\nRozwijanie: Jeśli pająk oddali się od ostatniego węzła o więcej niż X metrów, shader/skrypt dodaje nowy węzeł w miejscu pająka i tworzy nowe wiązanie między pająkiem a tym nowym węzłem.\nZwijanie/Rozwijanie (Góra/Dół):\nZamiast dodawać węzły, zmieniasz parametr rest_length ostatniego odcinka (tego przy pająku).\nJeśli rest_length spadnie do 0 – usuwasz segment.\nJeśli wzrośnie powyżej limitu – dodajesz nowy segment.\nPrzypnij (Pin): Kiedy pająk dotknie dowolnej ściany podczas wiszenia na linie, ostatni węzeł (przy pająku) zostaje zamieniony na „kotwicę” (masa = 0). Lina zostaje w świecie, a pająk jest wolny.\n5. Technologia (WebGPU + Three.js)\nCompute Shader: Liczy wszystkie Constraints i Particle Positions.\nThree.js: Używamy InstancedMesh (dla małych kulek-węzłów) oraz LineSegments do wizualizacji nici.\nProTip: WebGPU pozwala na Storage Buffer sharing. Oznacza to, że Compute Shader zapisuje pozycje prosto do bufora, który Three.js odczytuje jako bufor wierzchołków (Vertex Buffer) bez przesyłania danych przez CPU!\nScenariusz MVP (User Flow):\nPająk siedzi na lewej ścianie.\nGracz klika JUMP -> Pająk leci w prawo. Silnik tworzy „Kotwicę” na lewej ścianie i nitkę do pająka.\nPająk leci po łuku (wahadło). Gracz trzyma GÓRĘ -> lina się skraca, pająk podciąga się wyżej.\nPająk dolatuje do sufitu. Gracz klika PIN -> Nitka zostaje przymocowana do sufitu.\nMamy teraz nitkę rozpiętą między lewą ścianą a sufitem.\nPająk może teraz przejść po suficie i skoczyć z innego miejsca, budując kolejną nitkę."
    },
    {
      "filename": "package.json",
      "content": "{\n  \"name\": \"spider-web-physics\",\n  \"private\": true,\n  \"version\": \"0.0.111\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\"\n  },\n  \"dependencies\": {\n    \"@webgpu/types\": \"^0.1.43\",\n    \"miniplex\": \"^2.0.0\",\n    \"react\": \"^19.2.4\",\n    \"react-dom\": \"^19.2.4\",\n    \"three\": \"^0.182.0\"\n  },\n  \"devDependencies\": {\n    \"@types/bun\": \"latest\",\n    \"@types/react\": \"^19.2.14\",\n    \"@types/react-dom\": \"^19.2.3\",\n    \"@types/three\": \"^0.182.0\",\n    \"typescript\": \"^5.3.0\",\n    \"vite\": \"^5.0.0\"\n  },\n  \"peerDependencies\": {\n    \"typescript\": \"^5\"\n  }\n}\n"
    },
    {
      "filename": "requirements.md",
      "content": "# Web-Builder 2D Requirements\n\n## Functional Requirements\n- **Spider Movement (Wall/Ceiling):**\n  - Smooth movement along the 2D boundaries (Left, Right, Up, Down).\n  - Spider should automatically stick to walls/ceiling when touching them.\n- **Jump Mechanic:**\n  - Pressing Space detaches the spider from the wall.\n  - Initial velocity applied in the direction of the jump.\n- **Web Creation (Rope):**\n  - A line starts from the point where the spider jumped.\n  - The line follows the spider in the air.\n  - Rope length can be adjusted (Up/Down keys while in air).\n- **Pinning:**\n  - Pressing 'E' or touching another wall while in air attaches the current line permanently.\n- **Environment:**\n  - 2D rectangular box as boundaries.\n  - Constant gravity and a variable wind vector.\n\n## Technical Requirements\n- **Renderer:** Three.js using `WebGPURenderer`.\n- **Physics Engine:** Custom Compute Shader based on Position Based Dynamics (PBD).\n- **State Management:** Simple state machine for the spider (IDLE, CLIMBING, IN_AIR).\n- **Performance:** Target 60 FPS with thousands of rope segments using GPU buffers."
    },
    {
      "filename": "src/ecs.ts",
      "content": "import { World } from 'miniplex';\nimport * as THREE from 'three';\n\nexport type Entity = {\n    id: string;\n    name: string;\n    position: THREE.Vector2;\n    rotation: number;\n    scale: THREE.Vector2;\n    sdfCollider?: {\n        type: 'circle' | 'box';\n        size: THREE.Vector2;\n    };\n    physics?: {\n        bodyType: 'dynamic' | 'static' | 'kinematic';\n        mass: number;\n        invMass: number;\n        radius: number;\n        particleIdx?: number;\n    };\n    renderable?: {\n        mesh: THREE.Object3D;\n    };\n    attachable: boolean;\n    selected?: boolean;\n    tags: string[];\n};\n\nexport const world = new World<Entity>();"
    },
    {
      "filename": "src/main.tsx",
      "content": "import React, { useEffect, useRef, useState } from 'react';\nimport ReactDOM from 'react-dom/client';\nimport * as THREE from 'three';\n// @ts-ignore\nimport WebGPURenderer from 'three/src/renderers/webgpu/WebGPURenderer.js';\nimport { WebPhysics, CONFIG } from './webPhysics';\nimport { world, type Entity } from './ecs';\nimport { getMouseWorld } from './utils';\n\nconst BOUNDS = { width: 24, height: 14 };\n\ntype ToolMode = 'select' | 'build_line' | 'create_obj' | 'cut_line' | 'edit_obj' | 'joint';\ntype PlacementState = { type: 'static' | 'dynamic', shape: 'circle' | 'box' | 'rounded_box' | 'capsule' | 'vesica' } | null;\n\nconst App = () => {\n    const canvasRef = useRef<HTMLDivElement>(null);\n    const physicsRef = useRef<WebPhysics | null>(null);\n    \n    const [tool, setTool] = useState<ToolMode>('select');\n    const [lineBuildMode, setLineBuildMode] = useState<'manual' | 'auto'>('manual');\n    const [isPaused, setIsPaused] = useState(true);\n    const [showPanels, setShowPanels] = useState({ list: true, props: true });\n    const [selectedEntity, setSelectedEntity] = useState<Entity | null>(null);\n    const [isLevelMenuOpen, setIsLevelMenuOpen] = useState(false);\n    const [isCreateMenuOpen, setIsCreateMenuOpen] = useState(false);\n    const [placement, setPlacement] = useState<PlacementState>(null);\n    const [fps, setFps] = useState(0);\n\n    const toolRef = useRef(tool);\n    const lineBuildModeRef = useRef(lineBuildMode);\n    const isPausedRef = useRef(isPaused);\n    const placementRef = useRef(placement);\n    const ghostMeshRef = useRef<THREE.Mesh | null>(null);\n\n    useEffect(() => { \n        toolRef.current = tool; \n        if (tool !== 'create_obj') {\n            setPlacement(null);\n            setIsCreateMenuOpen(false);\n        }\n    }, [tool]);\n    \n    useEffect(() => { lineBuildModeRef.current = lineBuildMode; }, [lineBuildMode]);\n    useEffect(() => { isPausedRef.current = isPaused; }, [isPaused]);\n    \n    useEffect(() => {\n        placementRef.current = placement;\n        if (ghostMeshRef.current && physicsRef.current) {\n            physicsRef.current.scene.remove(ghostMeshRef.current);\n            ghostMeshRef.current = null;\n        }\n        if (placement && physicsRef.current) {\n            const geo = (placement.shape === 'circle' || placement.shape === 'vesica') ? new THREE.CircleGeometry(1, 32) : new THREE.BoxGeometry(1, 1, 0.1);\n            const mat = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 });\n            const mesh = new THREE.Mesh(geo, mat);\n            mesh.position.set(0, 0, 0.1);\n            physicsRef.current.scene.add(mesh);\n            ghostMeshRef.current = mesh;\n        }\n    }, [placement]);\n\n    const checkPlacementCollision = (pos: THREE.Vector2, _shape: string) => {\n        for (const ent of world.entities) {\n            if (!ent.sdfCollider && !ent.physics) continue;\n            if (pos.distanceTo(ent.position) < 0.5) return true;\n        }\n        return false;\n    };\n\n    useEffect(() => {\n        if (!canvasRef.current) return;\n        let scene: THREE.Scene, camera: THREE.OrthographicCamera, renderer: any;\n        let mouseWorld = new THREE.Vector2();\n        let frameCount = 0, lastTime = performance.now();\n        let alive = true;\n\n        const init = async () => {\n            scene = new THREE.Scene();\n            camera = new THREE.OrthographicCamera(-BOUNDS.width/2, BOUNDS.width/2, BOUNDS.height/2, -BOUNDS.height/2, 0.1, 1000);\n            camera.position.z = 10;\n            renderer = new WebGPURenderer({ antialias: true });\n            renderer.domElement.style.position = 'absolute';\n            renderer.domElement.style.top = '0';\n            renderer.domElement.style.left = '0';\n            renderer.setSize(canvasRef.current!.clientWidth, canvasRef.current!.clientHeight);\n            canvasRef.current?.appendChild(renderer.domElement);\n            await renderer.init();\n            const physics = new WebPhysics(renderer, scene, BOUNDS);\n            await physics.init();\n            physicsRef.current = physics;\n\n            const animate = () => {\n                if (!alive) return;\n                const now = performance.now();\n                frameCount++;\n                if (now - lastTime >= 1000) {\n                    setFps(frameCount); frameCount = 0; lastTime = now;\n                }\n                if (physics.ready) {\n                    physics.paused = isPausedRef.current;\n                    if (ghostMeshRef.current && placementRef.current) {\n                        ghostMeshRef.current.position.set(mouseWorld.x, mouseWorld.y, 0.1);\n                        const collided = checkPlacementCollision(mouseWorld, placementRef.current.shape);\n                        (ghostMeshRef.current.material as THREE.MeshBasicMaterial).color.set(collided ? 0xff0000 : 0x00ff00);\n                    }\n                    if (physics.activeRope && toolRef.current === 'build_line' && lineBuildModeRef.current === 'auto') {\n                        const rope = physics.activeRope;\n                        const tailIdx = rope.indices[rope.indices.length - 1];\n                        physics.setParticlePos(tailIdx, mouseWorld);\n                        let prevPos = physics.getParticlePos(rope.indices[rope.indices.length - 2]);\n                        let safety = 0;\n                        while (prevPos.distanceTo(mouseWorld) > CONFIG.SEGMENT_LENGTH * 1.3 && rope.indices.length < 500 && safety < 10) {\n                            physics.adjustRopeLength(rope, -1);\n                            prevPos = physics.getParticlePos(rope.indices[rope.indices.length - 2]);\n                            safety++;\n                        }\n                    }\n                    physics.syncObstacles();\n                    physics.update(mouseWorld);\n                }\n                renderer.render(scene, camera);\n                requestAnimationFrame(animate);\n            };\n\n            const onMouseMove = (e: MouseEvent) => {\n                if (!canvasRef.current) return;\n                const worldPos = getMouseWorld(e, canvasRef.current, BOUNDS);\n                mouseWorld.copy(worldPos);\n            };\n\n            const onMouseDown = (e: MouseEvent) => {\n                if (!canvasRef.current || e.target !== renderer.domElement) return;\n                const mWorld = getMouseWorld(e, canvasRef.current, BOUNDS);\n                if (e.button === 1) {\n                    setLineBuildMode(prev => prev === 'manual' ? 'auto' : 'manual');\n                    return;\n                }\n                if (!physics.ready) return;\n                if (placementRef.current && e.button === 0) {\n                    if (!checkPlacementCollision(mWorld, placementRef.current.shape)) {\n                        addObject(placementRef.current.type, placementRef.current.shape, { position: mWorld.clone() });\n                    }\n                    return;\n                }\n                if (toolRef.current === 'build_line') {\n                    const anchor = physics.findAnchor(mWorld);\n                    if (physics.activeRope) {\n                        if (anchor) physics.pinActiveRope(physics.activeRope, anchor);\n                    } else if (anchor) physics.createRope(anchor);\n                } else if (toolRef.current === 'select') {\n                   const pIdx = physics.getNearestParticle(mWorld, 0.5);\n                   const ent = [...world.entities].find(e => e.physics?.particleIdx === pIdx);\n                   if (ent) setSelectedEntity(ent);\n                   else {\n                       const statEnt = [...world.entities].find(e => e.sdfCollider && e.position.distanceTo(mWorld) < 1.5);\n                       setSelectedEntity(statEnt || null);\n                   }\n                }\n            };\n\n            window.addEventListener('mousemove', onMouseMove);\n            window.addEventListener('mousedown', onMouseDown);\n            window.addEventListener('contextmenu', (e) => e.preventDefault());\n            window.addEventListener('wheel', (e) => {\n                if (e.target === renderer.domElement && physics.activeRope && toolRef.current === 'build_line' && lineBuildModeRef.current === 'manual') {\n                    physics.adjustRopeLength(physics.activeRope, e.deltaY);\n                }\n            });\n            animate();\n            return () => {\n                alive = false;\n                window.removeEventListener('mousemove', onMouseMove);\n                window.removeEventListener('mousedown', onMouseDown);\n            };\n        };\n        init();\n    }, []);\n\n    const addObject = (type: 'static' | 'dynamic', shape: any, data?: Partial<Entity>) => {\n        if (!physicsRef.current) return;\n        const id = data?.id || Math.random().toString(36).substr(2, 9);\n        const name = data?.name || `${type}_${shape}_${id}`;\n        const pos = data?.position || new THREE.Vector2(0, 0);\n        let pIdx: number | undefined;\n        \n        const initialRadius = shape === 'circle' ? 1.0 : 0.5;\n        const initialSize = new THREE.Vector2(2, 2);\n\n        if (type === 'dynamic') pIdx = physicsRef.current.spawnBall(pos, 'dynamic', initialRadius, 10.0);\n\n        const mat = new THREE.MeshBasicMaterial({ color: type === 'static' ? 0x444444 : 0x00ff88 });\n        const geo = (shape === 'circle' || shape === 'vesica') ? new THREE.CircleGeometry(1, 32) : new THREE.BoxGeometry(1, 1, 0.1);\n        const mesh = new THREE.Mesh(geo, mat);\n        mesh.position.set(pos.x, pos.y, -0.1);\n        mesh.rotation.z = data?.rotation || 0;\n        mesh.scale.set(shape === 'circle' ? initialRadius : initialSize.x, shape === 'circle' ? initialRadius : initialSize.y, 1);\n        physicsRef.current.scene.add(mesh);\n\n        const ent: Entity = {\n            id, name, position: pos.clone(), rotation: data?.rotation || 0, scale: new THREE.Vector2(0.2, 0.2),\n            sdfCollider: type === 'static' ? { type: shape, size: shape === 'circle' ? new THREE.Vector2(initialRadius, 0) : initialSize.clone() } : undefined,\n            physics: type === 'dynamic' ? { bodyType: 'dynamic', mass: 10, invMass: 0.1, radius: initialRadius, particleIdx: pIdx } : undefined,\n            renderable: { mesh }, attachable: true, tags: [type]\n        };\n        world.add(ent); setSelectedEntity(ent); return ent;\n    };\n\n    const deleteEntity = (ent: Entity) => {\n        if (!physicsRef.current) return;\n        if (ent.renderable) physicsRef.current.scene.remove(ent.renderable.mesh);\n        if (ent.physics?.particleIdx !== undefined) physicsRef.current.freeParticle(ent.physics.particleIdx);\n        world.remove(ent); if (selectedEntity?.id === ent.id) setSelectedEntity(null);\n    };\n\n    const updatePhysicsFromUI = (ent: Entity) => {\n        if (!physicsRef.current) return;\n        if (ent.physics?.particleIdx !== undefined) {\n            physicsRef.current.setParticlePos(ent.physics.particleIdx, ent.position);\n            physicsRef.current.syncGPU();\n        }\n    };\n\n    return (\n        <div style={{ position: 'fixed', inset: 0, color: '#eee', fontFamily: 'monospace', display: 'flex', flexDirection: 'column', userSelect: 'none', background: '#222' }}>\n            <div style={{ height: 40, background: '#111', borderBottom: '1px solid #333', display: 'flex', alignItems: 'center', padding: '0 15px', gap: 20, zIndex: 10 }}>\n                <div style={{ fontWeight: 'bold', color: '#4a90e2' }}>PAJONK V0.1.4</div>\n                <div style={{ display: 'flex', gap: 10 }}>\n                   <div style={{ position: 'relative' }}>\n                       <button onClick={() => setIsLevelMenuOpen(!isLevelMenuOpen)} style={{ background: '#222', color: '#ccc', border: '1px solid #444', padding: '2px 10px', cursor: 'pointer' }}>Level ▾</button>\n                       {isLevelMenuOpen && (\n                           <div style={{ position: 'absolute', top: '100%', left: 0, background: '#222', border: '1px solid #444', zIndex: 100, display: 'flex', flexDirection: 'column', minWidth: 100 }}>\n                               <button onClick={() => { [...world.entities].forEach(deleteEntity); setIsLevelMenuOpen(false); }} style={{ padding: '8px 15px', border: 'none', background: 'none', color: '#fff', textAlign: 'left', cursor: 'pointer' }}>New</button>\n                               <button onClick={() => setIsLevelMenuOpen(false)} style={{ padding: '8px 15px', border: 'none', background: 'none', color: '#fff', textAlign: 'left', cursor: 'pointer' }}>Save</button>\n                               <button onClick={() => setIsLevelMenuOpen(false)} style={{ padding: '8px 15px', border: 'none', background: 'none', color: '#fff', textAlign: 'left', cursor: 'pointer' }}>Load</button>\n                           </div>\n                       )}\n                   </div>\n                   <button onClick={() => setIsPaused(!isPaused)} style={{ background: isPaused ? '#33aa33' : '#aa3333', border: 'none', borderRadius: 3, padding: '2px 12px', fontWeight: 'bold', cursor: 'pointer', color: 'white' }}>{isPaused ? '▶ PLAY' : '■ STOP'}</button>\n                </div>\n                <div style={{ marginLeft: 'auto', display: 'flex', gap: 15, fontSize: 11 }}>\n                    <label style={{ cursor: 'pointer' }}><input type=\"checkbox\" checked={showPanels.list} onChange={() => setShowPanels(p => ({...p, list: !p.list}))}/> List</label>\n                    <label style={{ cursor: 'pointer' }}><input type=\"checkbox\" checked={showPanels.props} onChange={() => setShowPanels(p => ({...p, props: !p.props}))}/> Props</label>\n                </div>\n            </div>\n\n            <div style={{ flex: 1, position: 'relative', display: 'flex', overflow: 'hidden' }}>\n                <div style={{ width: 240, flexShrink: 0, display: 'flex', flexDirection: 'column', background: '#111', borderRight: '1px solid #333' }}>\n                    {showPanels.list && (\n                        <div style={{ flex: selectedEntity ? '0 0 250px' : '1', padding: 10, overflowY: 'auto', borderBottom: selectedEntity ? '1px solid #333' : 'none' }}>\n                            <div style={{ fontSize: 10, marginBottom: 10, color: '#555', letterSpacing: '1px' }}>SCENE HIERARCHY</div>\n                            {world.entities.map(e => (\n                                <div key={e.id} onClick={() => setSelectedEntity(e)} style={{ padding: '6px 8px', fontSize: 11, borderLeft: selectedEntity?.id === e.id ? '2px solid #4a90e2' : '2px solid transparent', background: selectedEntity?.id === e.id ? '#1a1a1a' : 'transparent', cursor: 'pointer', marginBottom: 2, whiteSpace: 'nowrap', overflow: 'hidden', textOverflow: 'ellipsis', color: selectedEntity?.id === e.id ? '#fff' : '#aaa' }}>\n                                    {e.name}\n                                </div>\n                            ))}\n                        </div>\n                    )}\n                    {showPanels.props && selectedEntity && (\n                        <div style={{ flex: 1, padding: 12, fontSize: 12, overflowY: 'auto' }}>\n                            <div style={{ fontSize: 10, marginBottom: 15, color: '#555', letterSpacing: '1px' }}>PROPERTIES</div>\n                            <div style={{ display: 'flex', flexDirection: 'column', gap: 14 }}>\n                                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>\n                                    <span>Name</span>\n                                    <input value={selectedEntity.name} onChange={e => { selectedEntity.name = e.target.value; setSelectedEntity({...selectedEntity}); }} style={{ width: 110, background: '#000', color: '#fff', border: '1px solid #333', padding: '4px 6px' }}/>\n                                </div>\n                                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>\n                                    <span>Position</span>\n                                    <div style={{ display: 'flex', gap: 4 }}>\n                                        <input type=\"number\" value={selectedEntity.position.x} onChange={e => { selectedEntity.position.x = Number(e.target.value); updatePhysicsFromUI(selectedEntity); if (selectedEntity.renderable) selectedEntity.renderable.mesh.position.x = selectedEntity.position.x; setSelectedEntity({...selectedEntity}); }} step=\"0.1\" style={{ width: 50, background: '#000', color: '#fff', border: '1px solid #333' }}/>\n                                        <input type=\"number\" value={selectedEntity.position.y} onChange={e => { selectedEntity.position.y = Number(e.target.value); updatePhysicsFromUI(selectedEntity); if (selectedEntity.renderable) selectedEntity.renderable.mesh.position.y = selectedEntity.position.y; setSelectedEntity({...selectedEntity}); }} step=\"0.1\" style={{ width: 50, background: '#000', color: '#fff', border: '1px solid #333' }}/>\n                                    </div>\n                                </div>\n                                <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>\n                                    <span>Rotation</span>\n                                    <input type=\"number\" value={Math.round(THREE.MathUtils.radToDeg(selectedEntity.rotation))} onChange={e => { selectedEntity.rotation = THREE.MathUtils.degToRad(Number(e.target.value)); if (selectedEntity.renderable) selectedEntity.renderable.mesh.rotation.z = selectedEntity.rotation; setSelectedEntity({...selectedEntity}); }} step=\"5\" style={{ width: 104, background: '#000', color: '#fff', border: '1px solid #333', padding: '2px' }}/>\n                                </div>\n                                {selectedEntity.sdfCollider && (\n                                    <div style={{ display: 'flex', flexDirection: 'column', gap: 8, padding: '8px', background: '#000', borderRadius: 4 }}>\n                                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>\n                                            <span>Width / R1</span>\n                                            <input type=\"number\" value={selectedEntity.sdfCollider.size.x} onChange={e => { \n                                                selectedEntity.sdfCollider!.size.x = Number(e.target.value); \n                                                if (selectedEntity.renderable) selectedEntity.renderable.mesh.scale.x = selectedEntity.sdfCollider!.size.x; \n                                                setSelectedEntity({...selectedEntity}); \n                                            }} step=\"0.1\" style={{ width: 60, background: '#111', color: '#fff' }}/>\n                                        </div>\n                                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>\n                                            <span>Height / R2</span>\n                                            <input type=\"number\" value={selectedEntity.sdfCollider.size.y} onChange={e => { \n                                                selectedEntity.sdfCollider!.size.y = Number(e.target.value); \n                                                if (selectedEntity.renderable) selectedEntity.renderable.mesh.scale.y = (selectedEntity.sdfCollider!.type === 'circle' ? selectedEntity.sdfCollider!.size.x : selectedEntity.sdfCollider!.size.y); \n                                                setSelectedEntity({...selectedEntity}); \n                                            }} step=\"0.1\" style={{ width: 60, background: '#111', color: '#fff' }}/>\n                                        </div>\n                                        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}>\n                                            <span>Extra (H/Corner)</span>\n                                            <input type=\"number\" value={selectedEntity.scale.x} onChange={e => { selectedEntity.scale.x = Number(e.target.value); setSelectedEntity({...selectedEntity}); }} step=\"0.1\" style={{ width: 60, background: '#111', color: '#fff' }}/>\n                                        </div>\n                                    </div>\n                                )}\n                                <button onClick={() => deleteEntity(selectedEntity)} style={{ marginTop: 20, background: '#aa3333', color: '#fff', border: 'none', padding: '10px', cursor: 'pointer', fontWeight: 'bold' }}>DELETE OBJECT</button>\n                            </div>\n                        </div>\n                    )}\n                </div>\n\n                <div ref={canvasRef} style={{ flex: 1, position: 'relative', background: '#000', overflow: 'hidden' }}>\n                   <div style={{ position: 'absolute', bottom: 10, left: '50%', transform: 'translateX(-50%)', display: 'flex', gap: 2, background: '#111', padding: 3, borderRadius: 4, border: '1px solid #444', zIndex: 20 }}>\n                        <button onClick={() => setTool('select')} style={{ background: tool === 'select' ? '#4a90e2' : '#222', color: '#fff', border: 'none', padding: '6px 14px', fontSize: 11, cursor: 'pointer' }}>SELECT</button>\n                        <button onClick={() => setTool('build_line')} style={{ background: tool === 'build_line' ? '#4a90e2' : '#222', color: '#fff', border: 'none', padding: '6px 14px', fontSize: 11, cursor: 'pointer' }}>ROPE</button>\n                        <div style={{ position: 'relative' }}>\n                            <button onClick={() => { setTool('create_obj'); setIsCreateMenuOpen(!isCreateMenuOpen); }} style={{ background: tool === 'create_obj' ? '#4a90e2' : '#222', color: '#fff', border: 'none', padding: '6px 14px', fontSize: 11, cursor: 'pointer' }}>CREATE OBJ ▾</button>\n                            {isCreateMenuOpen && tool === 'create_obj' && (\n                                <div style={{ position: 'absolute', bottom: '100%', left: 0, background: '#111', border: '1px solid #444', display: 'flex', flexDirection: 'column', width: 140, marginBottom: 5 }}>\n                                    <button onClick={() => { setPlacement({type: 'static', shape: 'box'}); setIsCreateMenuOpen(false); }} style={{ padding: '8px', background: 'none', border: 'none', color: '#ccc', fontSize: 10, textAlign: 'left', cursor: 'pointer' }}>Static Box</button>\n                                    <button onClick={() => { setPlacement({type: 'static', shape: 'circle'}); setIsCreateMenuOpen(false); }} style={{ padding: '8px', background: 'none', border: 'none', color: '#ccc', fontSize: 10, textAlign: 'left', cursor: 'pointer' }}>Static Circ</button>\n                                    <button onClick={() => { setPlacement({type: 'static', shape: 'rounded_box'}); setIsCreateMenuOpen(false); }} style={{ padding: '8px', background: 'none', border: 'none', color: '#ccc', fontSize: 10, textAlign: 'left', cursor: 'pointer' }}>Rounded Box</button>\n                                    <button onClick={() => { setPlacement({type: 'static', shape: 'capsule'}); setIsCreateMenuOpen(false); }} style={{ padding: '8px', background: 'none', border: 'none', color: '#ccc', fontSize: 10, textAlign: 'left', cursor: 'pointer' }}>Uneven Capsule</button>\n                                    <button onClick={() => { setPlacement({type: 'static', shape: 'vesica'}); setIsCreateMenuOpen(false); }} style={{ padding: '8px', background: 'none', border: 'none', color: '#ccc', fontSize: 10, textAlign: 'left', cursor: 'pointer' }}>Vesica</button>\n                                    <button onClick={() => { setPlacement({type: 'dynamic', shape: 'circle'}); setIsCreateMenuOpen(false); }} style={{ padding: '8px', background: 'none', border: 'none', color: '#ccc', fontSize: 10, textAlign: 'left', cursor: 'pointer' }}>Dynamic Ball</button>\n                                </div>\n                            )}\n                        </div>\n                        <button onClick={() => setTool('cut_line')} style={{ background: tool === 'cut_line' ? '#4a90e2' : '#222', color: '#fff', border: 'none', padding: '6px 14px', fontSize: 11, cursor: 'pointer' }}>CUT</button>\n                   </div>\n                   <div style={{ position: 'absolute', top: 10, left: 10, color: '#444', fontSize: 10 }}>FPS: {fps} | Mode: {lineBuildMode.toUpperCase()}</div>\n                </div>\n            </div>\n        </div>\n    );\n};\n\nReactDOM.createRoot(document.getElementById('root')!).render(<App />);"
    },
    {
      "filename": "src/physics.wgsl",
      "content": "struct Particle {\n    pos: vec2<f32>,\n    oldPos: vec2<f32>,\n    isFree: f32,\n    pad: f32,\n    invMass: f32,\n    radius: f32,\n};\n\nstruct DistanceConstraint {\n    idxA: u32,\n    idxB: u32,\n    restLength: f32,\n    compliance: f32,\n};\n\nstruct Attachment {\n    pIdx: u32,\n    aIdx: u32,\n    bIdx: u32,\n    t: f32,\n};\n\nstruct Obstacle {\n    pos: vec2<f32>,\n    size: vec2<f32>, \n    type_id: u32,    \n    rotation: f32,   \n    extra: vec2<f32>,\n};\n\nstruct Params {\n    dt: f32,\n    gravity: f32,\n    numParticles: u32,\n    numDistConstraints: u32,\n    substeps: u32,\n    phase: u32,\n    mousePos: vec2<f32>,\n    activeParticleIdx: i32,\n    numAttachments: u32,\n    damping: f32,\n    paused: u32,\n    numObstacles: u32,\n};\n\n@group(0) @binding(0) var<storage, read_write> particles: array<Particle>;\n@group(0) @binding(1) var<storage, read> distConstraints: array<DistanceConstraint>;\n@group(0) @binding(2) var<storage, read> attachments: array<Attachment>;\n@group(0) @binding(3) var<uniform> params: Params;\n@group(0) @binding(4) var<storage, read> obstacles: array<Obstacle>;\n\nfn rotate(v: vec2<f32>, angle: f32) -> vec2<f32> {\n    let s = sin(angle);\n    let c = cos(angle);\n    return vec2<f32>(v.x * c - v.y * s, v.x * s + v.y * c);\n}\n\nfn sdRoundedBox(p: vec2<f32>, b: vec2<f32>, r: f32) -> f32 {\n    let q = abs(p) - b + r;\n    return min(max(q.x, q.y), 0.0) + length(max(q, vec2<f32>(0.0))) - r;\n}\n\nfn sdUnevenCapsule(p: vec2<f32>, r1: f32, r2: f32, h: f32) -> f32 {\n    let px = abs(p.x);\n    let b = (r1 - r2) / h;\n    let a = sqrt(max(0.0, 1.0 - b * b));\n    let k = dot(vec2<f32>(px, p.y), vec2<f32>(-b, a));\n    if (k < 0.0) { return length(vec2<f32>(px, p.y)) - r1; }\n    if (k > a * h) { return length(vec2<f32>(px, p.y - h)) - r2; }\n    return dot(vec2<f32>(px, p.y), vec2<f32>(a, b)) - r1;\n}\n\nfn sdVesica(p: vec2<f32>, r: f32, d: f32) -> f32 {\n    let pa = abs(p);\n    let b = sqrt(max(0.0, r * r - d * d));\n    return select(length(pa - vec2<f32>(-d, 0.0)) - r, length(pa - vec2<f32>(0.0, b)), pa.y * d > pa.x * b + d * d);\n}\n\nfn getSDF(p: vec2<f32>, obs: Obstacle) -> f32 {\n    let localP = rotate(p - obs.pos, -obs.rotation);\n    if (obs.type_id == 0u) {\n        return length(localP) - obs.size.x;\n    } else if (obs.type_id == 1u) {\n        let d = abs(localP) - obs.size * 0.5;\n        return length(max(d, vec2<f32>(0.0))) + min(max(d.x, d.y), 0.0);\n    } else if (obs.type_id == 2u) {\n        return sdRoundedBox(localP, obs.size * 0.5, obs.extra.x);\n    } else if (obs.type_id == 3u) {\n        return sdUnevenCapsule(localP, obs.size.x, obs.size.y, obs.extra.x);\n    } else if (obs.type_id == 4u) {\n        return sdVesica(localP, obs.size.x, obs.size.y);\n    }\n    return 1000.0;\n}\n\nfn getInvMass(i: u32) -> f32 {\n    let p = particles[i];\n    if (params.paused == 1u && p.isFree == 0.0 && i != u32(params.activeParticleIdx)) {\n        return 0.0;\n    }\n    return p.invMass;\n}\n\n@compute @workgroup_size(64)\nfn integrate(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x;\n    if (i >= params.numParticles) { return; }\n    var p = particles[i];\n    if (i == u32(params.activeParticleIdx)) {\n        particles[i].pos = params.mousePos;\n        particles[i].oldPos = params.mousePos;\n        return;\n    }\n    if (params.paused == 1u && p.isFree == 0.0) {\n        particles[i].oldPos = p.pos;\n        return;\n    }\n    if (p.invMass <= 0.0) { return; }\n    let h = params.dt / f32(params.substeps);\n    var vel = (p.pos - p.oldPos) / h;\n    vel = vel * params.damping;\n    vel = vel + vec2<f32>(0.0, params.gravity) * h;\n    particles[i].oldPos = p.pos;\n    particles[i].pos = p.pos + vel * h;\n}\n\n@compute @workgroup_size(64)\nfn solveDistance(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x;\n    if (i >= params.numDistConstraints || i % 2u != params.phase) { return; }\n    let c = distConstraints[i];\n    let w1 = getInvMass(c.idxA); \n    let w2 = getInvMass(c.idxB);\n    let wSum = w1 + w2; if (wSum <= 0.0) { return; }\n    let delta = particles[c.idxA].pos - particles[c.idxB].pos;\n    let dist = length(delta); if (dist < 0.0001) { return; }\n    let h = params.dt / f32(params.substeps);\n    let alpha = c.compliance / (h * h);\n    let dLambda = -(dist - c.restLength) / (wSum + alpha);\n    let correction = delta * (dLambda / dist);\n    if (w1 > 0.0) { particles[c.idxA].pos += correction * w1; }\n    if (w2 > 0.0) { particles[c.idxB].pos -= correction * w2; }\n}\n\n@compute @workgroup_size(64)\nfn solveAttachments(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x; if (i >= params.numAttachments) { return; }\n    let att = attachments[i];\n    let p = particles[att.pIdx].pos;\n    let a = particles[att.aIdx].pos;\n    let b = particles[att.bIdx].pos;\n    let link_target = mix(a, b, att.t);\n    let delta = p - link_target; let dist = length(delta); if (dist < 0.00001) { return; }\n    let wp = getInvMass(att.pIdx); \n    let wa = getInvMass(att.aIdx); \n    let wb = getInvMass(att.bIdx);\n    let wSum = wp + wa * (1.0 - att.t) * (1.0 - att.t) + wb * att.t * att.t;\n    if (wSum <= 0.0) { return; }\n    let correction = normalize(delta) * (-dist / wSum);\n    if (wp > 0.0) { particles[att.pIdx].pos += correction * wp; }\n    if (wa > 0.0) { particles[att.aIdx].pos -= correction * wa * (1.0 - att.t); }\n    if (wb > 0.0) { particles[att.bIdx].pos -= correction * wb * att.t; }\n}\n\n@compute @workgroup_size(64)\nfn solveCollisions(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x; if (i >= params.numParticles) { return; }\n    var p = particles[i]; \n    let invMassI = getInvMass(i);\n    if (invMassI <= 0.0) { return; }\n\n    let bx = 11.8; let by = 6.8;\n    if (p.pos.x > bx - p.radius) { p.pos.x = bx - p.radius; p.oldPos.x = p.pos.x; }\n    if (p.pos.x < -bx + p.radius) { p.pos.x = -bx + p.radius; p.oldPos.x = p.pos.x; }\n    if (p.pos.y > by - p.radius) { p.pos.y = by - p.radius; p.oldPos.y = p.pos.y; }\n    if (p.pos.y < -by + p.radius) { p.pos.y = -by + p.radius; p.oldPos.y = p.pos.y; }\n\n    for (var j: u32 = 0u; j < params.numObstacles; j++) {\n        let obs = obstacles[j];\n        let d = getSDF(p.pos, obs);\n        if (d < p.radius) {\n            let h = 0.01;\n            let dx = getSDF(p.pos + vec2<f32>(h, 0.0), obs) - d;\n            let dy = getSDF(p.pos + vec2<f32>(0.0, h), obs) - d;\n            let n = normalize(vec2<f32>(dx, dy));\n            p.pos = p.pos + n * (p.radius - d);\n            p.oldPos = p.pos;\n        }\n    }\n    particles[i].pos = p.pos;\n}\n\n@compute @workgroup_size(64)\nfn solveParticleCollisions(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x; if (i >= params.numParticles) { return; }\n    var pi = particles[i]; \n    let w1 = getInvMass(i);\n    if (w1 <= 0.0) { return; }\n    \n    for (var j: u32 = 0u; j < params.numParticles; j++) {\n        if (i == j) { continue; }\n        let pj = particles[j];\n        let delta = pi.pos - pj.pos; let dist = length(delta); let minDist = pi.radius + pj.radius;\n        if (dist < minDist && dist > 0.0001) {\n            let w2 = getInvMass(j);\n            let wSum = w1 + w2;\n            if (wSum > 0.0) { \n                let n = delta / dist; let overlap = minDist - dist; \n                pi.pos += n * (overlap / wSum) * w1 * 0.5; \n            }\n        }\n    }\n    particles[i].pos = pi.pos;\n}"
    },
    {
      "filename": "src/utils.ts",
      "content": "import * as THREE from 'three';\n\n/**\n * Converts screen mouse coordinates to game world coordinates.\n * @param e The mouse or wheel event.\n * @param container The canvas container element.\n * @param bounds The game world bounds (width/height).\n */\nexport const getMouseWorld = (\n    e: MouseEvent | WheelEvent,\n    container: HTMLElement,\n    bounds: { width: number; height: number }\n): THREE.Vector2 => {\n    const rect = container.getBoundingClientRect();\n    // Normalize to [-1, 1]\n    const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;\n    const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;\n    // Map to game units\n    return new THREE.Vector2(x * (bounds.width / 2), y * (bounds.height / 2));\n};"
    },
    {
      "filename": "src/webPhysics.ts",
      "content": "import * as THREE from 'three';\nimport { world, type Entity } from './ecs';\n\nexport const CONFIG = {\n    SEGMENT_LENGTH: 0.08,\n    ROPE_NODE_MASS: 1.0,\n    ROPE_COMPLIANCE: 0.00001,\n    VELOCITY_DAMPING: 0.9995,\n    GRAVITY: -40.0\n};\n\nconst MAX_PARTICLES = 16384;\nconst MAX_CONSTRAINTS = 16384;\nconst MAX_ATTACHMENTS = 4096;\nconst MAX_OBSTACLES = 256;\n\nexport class WebPhysics {\n    renderer: any; scene: THREE.Scene; bounds: { width: number; height: number }; ready: boolean = false; paused: boolean = false;\n    particles = new Float32Array(MAX_PARTICLES * 8);\n    particleActive = new Uint8Array(MAX_PARTICLES);\n    distConstraints = new Float32Array(MAX_CONSTRAINTS * 4);\n    constraintVisible = new Uint8Array(MAX_CONSTRAINTS);\n    attachments = new Float32Array(MAX_ATTACHMENTS * 4);\n    obstacles = new Float32Array(MAX_OBSTACLES * 8);\n\n    numParticles = 0; numDistConstraints = 0; numAttachments = 0; numObstacles = 0;\n    ropes: any[] = []; activeRope: any = null;\n    dirtyParticles = new Set<number>(); freeParticleIndices: number[] = []; freeConstraintIndices: number[] = [];\n\n    device: GPUDevice | null = null;\n    particleBuffer: GPUBuffer | null = null; distConstraintBuffer: GPUBuffer | null = null;\n    attachmentBuffer: GPUBuffer | null = null; obstacleBuffer: GPUBuffer | null = null;\n    paramsBuffer0: GPUBuffer | null = null; paramsBuffer1: GPUBuffer | null = null; stagingBuffer: GPUBuffer | null = null;\n    bindGroup0: GPUBindGroup | null = null; bindGroup1: GPUBindGroup | null = null;\n    pipelines: Record<string, GPUComputePipeline> = {}; isReadingBack = false;\n\n    dragParticleIdx: number = -1;\n    constraintLines: THREE.LineSegments | null = null;\n\n    constructor(renderer: any, scene: THREE.Scene, bounds: { width: number; height: number }) {\n        this.renderer = renderer; this.scene = scene; this.bounds = bounds;\n    }\n\n    async init() {\n        const device = this.renderer.device || this.renderer.backend?.device;\n        if (!device) throw new Error('WebGPU device not found');\n        this.device = device;\n\n        const shaderCode = await (await fetch('/src/physics.wgsl')).text();\n        const shaderModule = device.createShaderModule({ code: shaderCode });\n\n        this.particleBuffer = device.createBuffer({ size: this.particles.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });\n        this.distConstraintBuffer = device.createBuffer({ size: this.distConstraints.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });\n        this.attachmentBuffer = device.createBuffer({ size: this.attachments.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });\n        this.obstacleBuffer = device.createBuffer({ size: this.obstacles.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });\n\n        this.paramsBuffer0 = device.createBuffer({ size: 96, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });\n        this.paramsBuffer1 = device.createBuffer({ size: 96, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });\n        this.stagingBuffer = device.createBuffer({ size: this.particles.byteLength, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST });\n\n        const bgl = device.createBindGroupLayout({\n            entries: [\n                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },\n                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },\n                { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } },\n                { binding: 4, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } }\n            ]\n        });\n\n        const createBG = (pBuf: GPUBuffer) => device.createBindGroup({\n            layout: bgl,\n            entries: [\n                { binding: 0, resource: { buffer: this.particleBuffer! } },\n                { binding: 1, resource: { buffer: this.distConstraintBuffer! } },\n                { binding: 2, resource: { buffer: this.attachmentBuffer! } },\n                { binding: 3, resource: { buffer: pBuf } },\n                { binding: 4, resource: { buffer: this.obstacleBuffer! } }\n            ]\n        });\n\n        this.bindGroup0 = createBG(this.paramsBuffer0!); this.bindGroup1 = createBG(this.paramsBuffer1!);\n        const layout = device.createPipelineLayout({ bindGroupLayouts: [bgl] });\n        const createPipe = (entry: string) => device.createComputePipeline({ layout, compute: { module: shaderModule, entryPoint: entry } });\n\n        ['integrate', 'solveDistance', 'solveAttachments', 'solveParticleCollisions', 'solveCollisions'].forEach(e => this.pipelines[e] = createPipe(e));\n        \n        const constraintGeo = new THREE.BufferGeometry();\n        constraintGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(MAX_CONSTRAINTS * 6), 3));\n        this.constraintLines = new THREE.LineSegments(constraintGeo, new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 }));\n        this.scene.add(this.constraintLines);\n        \n        this.ready = true;\n    }\n\n    syncObstacles() {\n        const statics = world.with('sdfCollider', 'position');\n        let count = 0;\n        this.obstacles.fill(0);\n        for (const ent of statics) {\n            if (count >= MAX_OBSTACLES) break;\n            const off = count * 8;\n            this.obstacles[off] = ent.position.x;\n            this.obstacles[off + 1] = ent.position.y;\n            this.obstacles[off + 2] = ent.sdfCollider.size.x;\n            this.obstacles[off + 3] = ent.sdfCollider.size.y;\n            const uv = new Uint32Array(this.obstacles.buffer);\n            const typeMap: Record<string, number> = { 'circle': 0, 'box': 1, 'rounded_box': 2, 'capsule': 3, 'vesica': 4 };\n            uv[off + 4] = typeMap[ent.sdfCollider.type] || 0;\n            this.obstacles[off + 5] = ent.rotation;\n            this.obstacles[off + 6] = ent.scale.x; \n            this.obstacles[off + 7] = ent.scale.y;\n            count++;\n        }\n        this.numObstacles = count;\n        this.device?.queue.writeBuffer(this.obstacleBuffer!, 0, this.obstacles);\n    }\n\n    allocParticle() { \n        if (this.numParticles >= MAX_PARTICLES && this.freeParticleIndices.length === 0) return -1;\n        const idx = this.freeParticleIndices.length > 0 ? this.freeParticleIndices.pop()! : this.numParticles++; \n        this.particleActive[idx] = 1;\n        return idx;\n    }\n    freeParticle(idx: number) { \n        this.freeParticleIndices.push(idx); \n        this.particleActive[idx] = 0;\n        this.setParticle(idx, new THREE.Vector2(0,0), 0); \n    }\n    allocConstraint() { \n        if (this.numDistConstraints >= MAX_CONSTRAINTS && this.freeConstraintIndices.length === 0) return -1;\n        const idx = this.freeConstraintIndices.length > 0 ? this.freeConstraintIndices.pop()! : this.numDistConstraints++; \n        this.constraintVisible[idx] = 1;\n        return idx;\n    }\n    freeConstraint(idx: number) { this.freeConstraintIndices.push(idx); this.setDistConstraint(idx, 0,0,0,0); }\n\n    setParticle(i: number, pos: THREE.Vector2, invMass: number) {\n        const off = i * 8; \n        this.particles[off] = pos.x; \n        this.particles[off+1] = pos.y; \n        this.particles[off+2] = pos.x; \n        this.particles[off+3] = pos.y; \n        this.particles[off+4] = 0.0; \n        this.particles[off+5] = 0.0; \n        this.particles[off+6] = invMass; \n        this.particles[off+7] = 0.04; \n        this.dirtyParticles.add(i);\n    }\n    \n    setParticleFree(i: number, isFree: boolean) {\n        this.particles[i * 8 + 4] = isFree ? 1.0 : 0.0;\n        this.dirtyParticles.add(i);\n    }\n\n    setParticlePos(i: number, pos: THREE.Vector2) {\n        const off = i * 8; this.particles[off] = pos.x; this.particles[off+1] = pos.y; this.particles[off+2] = pos.x; this.particles[off+3] = pos.y; \n        this.dirtyParticles.add(i);\n    }\n    setDistConstraint(i: number, a: number, b: number, len: number, comp: number) {\n        const off = i * 4; const uv = new Uint32Array(this.distConstraints.buffer); uv[off] = a; uv[off+1] = b; this.distConstraints[off+2] = len; this.distConstraints[off+3] = comp;\n    }\n    addAttachment(pIdx: number, aIdx: number, bIdx: number, t: number) {\n        const off = this.numAttachments * 4; const uv = new Uint32Array(this.attachments.buffer); uv[off] = pIdx; uv[off+1] = aIdx; uv[off+2] = bIdx; this.attachments[off+3] = t; this.numAttachments++;\n    }\n    syncGPU() { \n        this.device?.queue.writeBuffer(this.particleBuffer!, 0, this.particles);\n        this.device?.queue.writeBuffer(this.distConstraintBuffer!, 0, this.distConstraints);\n        this.device?.queue.writeBuffer(this.attachmentBuffer!, 0, this.attachments);\n    }\n\n    update(mousePos: THREE.Vector2) {\n        if (!this.ready || this.isReadingBack) return;\n        const dt = 1/60, subs = 8;\n        \n        const activeIdx = this.dragParticleIdx !== -1 ? this.dragParticleIdx : (this.activeRope ? this.activeRope.indices[this.activeRope.indices.length-1] : -1);\n\n        const fill = (ph: number) => {\n            const b = new ArrayBuffer(96), f = new Float32Array(b), u = new Uint32Array(b), i = new Int32Array(b);\n            f[0] = dt; f[1] = CONFIG.GRAVITY; u[2] = this.numParticles; u[3] = this.numDistConstraints; u[4] = subs; u[5] = ph; f[6] = mousePos.x; f[7] = mousePos.y; i[8] = activeIdx; u[9] = this.numAttachments; f[10] = CONFIG.VELOCITY_DAMPING; u[11] = this.paused ? 1 : 0; u[12] = this.numObstacles;\n            return b;\n        };\n        this.device?.queue.writeBuffer(this.paramsBuffer0!, 0, fill(0)); this.device?.queue.writeBuffer(this.paramsBuffer1!, 0, fill(1));\n        const enc = this.device!.createCommandEncoder();\n        \n        for (let s = 0; s < subs; s++) {\n            const p1 = enc.beginComputePass(); p1.setBindGroup(0, this.bindGroup0!); p1.setPipeline(this.pipelines.integrate!); p1.dispatchWorkgroups(Math.ceil(this.numParticles/64)); p1.end();\n            for (let i = 0; i < 4; i++) {\n                const d0 = enc.beginComputePass(); d0.setBindGroup(0, this.bindGroup0!); d0.setPipeline(this.pipelines.solveDistance!); d0.dispatchWorkgroups(Math.ceil(this.numDistConstraints/64)); d0.end();\n                const d1 = enc.beginComputePass(); d1.setBindGroup(0, this.bindGroup1!); d1.setPipeline(this.pipelines.solveDistance!); d1.dispatchWorkgroups(Math.ceil(this.numDistConstraints/64)); d1.end();\n                const at = enc.beginComputePass(); at.setBindGroup(0, this.bindGroup0!); at.setPipeline(this.pipelines.solveAttachments!); at.dispatchWorkgroups(Math.ceil(this.numAttachments/64)); at.end();\n            }\n            const c0 = enc.beginComputePass(); c0.setBindGroup(0, this.bindGroup0!); c0.setPipeline(this.pipelines.solveParticleCollisions!); c0.dispatchWorkgroups(Math.ceil(this.numParticles/64)); c0.end();\n            const c1 = enc.beginComputePass(); c1.setBindGroup(0, this.bindGroup0!); c1.setPipeline(this.pipelines.solveCollisions!); c1.dispatchWorkgroups(Math.ceil(this.numParticles/64)); c1.end();\n        }\n        \n        enc.copyBufferToBuffer(this.particleBuffer!, 0, this.stagingBuffer!, 0, this.particles.byteLength);\n        this.device?.queue.submit([enc.finish()]);\n        this.readBackAndVisualize();\n    }\n\n    readBackAndVisualize() {\n        if (!this.stagingBuffer || this.isReadingBack) return;\n        this.isReadingBack = true;\n        this.stagingBuffer.mapAsync(GPUMapMode.READ).then(() => {\n            const data = new Float32Array(this.stagingBuffer!.getMappedRange());\n            const dirty = Array.from(this.dirtyParticles).map(i => ({i, data: this.particles.slice(i*8, i*8+8)}));\n            this.particles.set(data); dirty.forEach(b => this.particles.set(b.data, b.i*8)); this.dirtyParticles.clear();\n            this.stagingBuffer!.unmap(); this.isReadingBack = false; this.updateVisuals();\n        }).catch(() => this.isReadingBack = false);\n    }\n\n    updateVisuals() {\n        if (this.constraintLines) {\n            const posAttr = this.constraintLines.geometry.getAttribute('position');\n            let drawCount = 0;\n            const uv = new Uint32Array(this.distConstraints.buffer);\n            for(let i=0; i<this.numDistConstraints; i++) {\n                if (this.constraintVisible[i] === 0) continue;\n                const a = uv[i*4], b = uv[i*4+1];\n                if (a === b) continue;\n                posAttr.setXYZ(drawCount*2, this.particles[a*8], this.particles[a*8+1], 0);\n                posAttr.setXYZ(drawCount*2+1, this.particles[b*8], this.particles[b*8+1], 0);\n                drawCount++;\n            }\n            this.constraintLines.geometry.setDrawRange(0, drawCount*2);\n            posAttr.needsUpdate = true;\n        }\n\n        const dynamics = world.with('physics', 'renderable');\n        for (const ent of dynamics) {\n            if (ent.physics.particleIdx !== undefined) {\n                const off = ent.physics.particleIdx * 8;\n                ent.position.set(this.particles[off], this.particles[off + 1]);\n                ent.renderable.mesh.position.set(ent.position.x, ent.position.y, -0.1);\n            }\n        }\n    }\n\n    getParticlePos(i: number) { return new THREE.Vector2(this.particles[i*8], this.particles[i*8+1]); }\n    \n    getNearestParticle(pos: THREE.Vector2, maxDist: number) {\n        let nearest = -1;\n        let minDistSq = maxDist * maxDist;\n        for (let i = 0; i < this.numParticles; i++) {\n            if (!this.particleActive[i]) continue;\n            const px = this.particles[i*8], py = this.particles[i*8+1];\n            const distSq = (px - pos.x)**2 + (py - pos.y)**2;\n            if (distSq < minDistSq) {\n                minDistSq = distSq;\n                nearest = i;\n            }\n        }\n        return nearest;\n    }\n\n    findIntersectingConstraint(pos: THREE.Vector2, radius: number) {\n        const uv = new Uint32Array(this.distConstraints.buffer);\n        let closest = -1;\n        let minDist = radius;\n        for(let i=0; i<this.numDistConstraints; i++) {\n            if (this.constraintVisible[i] === 0) continue;\n            const a = uv[i*4], b = uv[i*4+1];\n            if (a === b) continue;\n            const pA = new THREE.Vector2(this.particles[a*8], this.particles[a*8+1]);\n            const pB = new THREE.Vector2(this.particles[b*8], this.particles[b*8+1]);\n            const l2 = pA.distanceToSquared(pB);\n            if (l2 === 0) continue;\n            let t = ((pos.x - pA.x) * (pB.x - pA.x) + (pos.y - pA.y) * (pB.y - pA.y)) / l2;\n            t = Math.max(0, Math.min(1, t));\n            const proj = new THREE.Vector2(pA.x + t * (pB.x - pA.x), pA.y + t * (pB.y - pA.y));\n            const d = pos.distanceTo(proj);\n            if (d < minDist) {\n                minDist = d;\n                closest = i;\n            }\n        }\n        return closest;\n    }\n\n    createJoint(a: number, b: number) {\n        const cIdx = this.allocConstraint();\n        if (cIdx === -1) return;\n        const pA = this.getParticlePos(a);\n        const pB = this.getParticlePos(b);\n        const dist = pA.distanceTo(pB);\n        this.setDistConstraint(cIdx, a, b, dist, 0.000001);\n        this.syncGPU();\n        this.updateVisuals();\n    }\n\n    findAnchor(pos: THREE.Vector2): any {\n        const bx=11.8, by=6.8, th=0.5;\n        if (Math.abs(pos.x)>bx-th || Math.abs(pos.y)>by-th) return { pos: pos.clone().clamp(new THREE.Vector2(-bx,-by), new THREE.Vector2(bx,by)), type: 'static' };\n        \n        const pIdx = this.getNearestParticle(pos, 1.0);\n        if (pIdx !== -1) {\n            // Check if this particle belongs to an attachable entity\n            const ent = [...world.entities].find(e => e.physics?.particleIdx === pIdx);\n            if (ent && !ent.attachable) return null;\n\n            const pPos = this.getParticlePos(pIdx);\n            const radius = this.particles[pIdx*8+7];\n            const nodeRadius = 0.04;\n            const dir = pos.clone().sub(pPos);\n            if (dir.lengthSq() === 0) dir.set(1, 0);\n            dir.normalize();\n            const surfacePos = pPos.clone().add(dir.multiplyScalar(radius + nodeRadius));\n            return { pos: surfacePos, type: 'particle', targetIdx: pIdx, distance: radius + nodeRadius };\n        }\n\n        // Map obstacles back to entities for attachment check\n        const statics = world.with('sdfCollider', 'position');\n        const staticArr = [...statics];\n\n        for (let i = 0; i < this.numObstacles; i++) {\n            const ent = staticArr[i];\n            if (ent && !ent.attachable) continue;\n\n            const off = i * 8;\n            const obsPos = new THREE.Vector2(this.obstacles[off], this.obstacles[off+1]);\n            const obsSize = new THREE.Vector2(this.obstacles[off+2], this.obstacles[off+3]);\n            const type = new Uint32Array(this.obstacles.buffer)[off+4];\n            if (type === 0) {\n                if (pos.distanceTo(obsPos) < obsSize.x + th) {\n                    const dir = pos.clone().sub(obsPos);\n                    if (dir.lengthSq() === 0) dir.set(1, 0);\n                    const surfacePos = obsPos.clone().add(dir.normalize().multiplyScalar(obsSize.x));\n                    return { pos: surfacePos, type: 'static' };\n                }\n            } else {\n                const half = obsSize.clone().multiplyScalar(0.5);\n                const d = new THREE.Vector2(Math.abs(pos.x - obsPos.x) - half.x, Math.abs(pos.y - obsPos.y) - half.y);\n                if (Math.max(d.x, d.y) < th) {\n                    const localPos = pos.clone().sub(obsPos);\n                    if (Math.abs(localPos.x) / half.x > Math.abs(localPos.y) / half.y) {\n                        localPos.x = Math.sign(localPos.x || 1) * half.x;\n                    } else {\n                        localPos.y = Math.sign(localPos.y || 1) * half.y;\n                    }\n                    return { pos: obsPos.clone().add(localPos), type: 'static' };\n                }\n            }\n        }\n        \n        return null;\n    }\n\n    createRope(anchor: any) {\n        const idxA = this.allocParticle(); if (idxA === -1) return null;\n        const idxB = this.allocParticle(); if (idxB === -1) { this.freeParticle(idxA); return null; }\n        const cIdx = this.allocConstraint(); if (cIdx === -1) { this.freeParticle(idxA); this.freeParticle(idxB); return null; }\n        const indices = [idxA, idxB];\n        this.setParticle(idxA, anchor.pos, anchor.type==='static'?0:1/CONFIG.ROPE_NODE_MASS); \n        this.setParticle(idxB, anchor.pos, 1/CONFIG.ROPE_NODE_MASS);\n        \n        this.setParticleFree(idxA, true);\n        this.setParticleFree(idxB, true);\n        \n        const rope = { indices, constraintIndices: [cIdx], anchorConstraints: [] as number[], segments: 1, segmentLength: CONFIG.SEGMENT_LENGTH };\n\n        if (anchor.type==='particle') {\n            const extraC = this.allocConstraint();\n            if (extraC !== -1) {\n                this.constraintVisible[extraC] = 0;\n                this.setDistConstraint(extraC, idxA, anchor.targetIdx, anchor.distance + 0.02, 0);\n                rope.anchorConstraints.push(extraC);\n            }\n        }\n        \n        this.setDistConstraint(cIdx, idxA, idxB, CONFIG.SEGMENT_LENGTH, CONFIG.ROPE_COMPLIANCE);\n        this.ropes.push(rope); this.activeRope = rope; this.syncGPU(); return rope;\n    }\n\n    pinActiveRope(rope: any, anchor: any) {\n        const last = rope.indices[rope.indices.length-1]; \n        this.setParticle(last, anchor.pos, anchor.type==='static'?0:1/CONFIG.ROPE_NODE_MASS);\n        \n        if (anchor.type==='particle') {\n            const extraC = this.allocConstraint();\n            if (extraC !== -1) {\n                this.constraintVisible[extraC] = 0;\n                this.setDistConstraint(extraC, last, anchor.targetIdx, anchor.distance + 0.02, 0);\n                rope.anchorConstraints.push(extraC);\n            }\n        }\n        \n        rope.indices.forEach((idx: number) => this.setParticleFree(idx, false));\n        this.activeRope = null; \n        this.syncGPU();\n    }\n\n    adjustRopeLength(rope: any, delta: number) {\n        const SEG = CONFIG.SEGMENT_LENGTH;\n        if (delta < 0 && rope.indices.length < 500) {\n            const tail = rope.indices[rope.indices.length-1];\n            const prev = rope.indices[rope.indices.length-2];\n            \n            const tailPos = this.getParticlePos(tail);\n            const prevPos = this.getParticlePos(prev);\n            \n            const newIdx = this.allocParticle(); \n            if (newIdx === -1) return;\n\n            const dir = tailPos.clone().sub(prevPos);\n            const dist = dir.length();\n            const step = dist > 0 ? dir.normalize().multiplyScalar(Math.min(dist * 0.5, SEG)) : new THREE.Vector2(SEG, 0);\n            \n            this.setParticle(newIdx, prevPos.clone().add(step), 1/CONFIG.ROPE_NODE_MASS);\n            this.setParticleFree(newIdx, true);\n            \n            const lastC = rope.constraintIndices[rope.constraintIndices.length-1]; \n            this.setDistConstraint(lastC, prev, newIdx, SEG, CONFIG.ROPE_COMPLIANCE);\n            \n            const newC = this.allocConstraint(); \n            if (newC === -1) {\n                this.freeParticle(newIdx);\n                this.setDistConstraint(lastC, prev, tail, SEG, CONFIG.ROPE_COMPLIANCE);\n                return;\n            }\n            rope.constraintIndices.push(newC); \n            this.setDistConstraint(newC, newIdx, tail, SEG, CONFIG.ROPE_COMPLIANCE);\n            \n            rope.indices.splice(rope.indices.length - 1, 0, newIdx);\n            rope.segments++; \n            this.syncGPU();\n        } else if (delta > 0 && rope.indices.length > 2) {\n            const tail = rope.indices.pop()!; \n            const rem = rope.indices.pop()!; \n            rope.indices.push(tail); \n            this.freeParticle(rem);\n            \n            const remC = rope.constraintIndices.pop()!; \n            this.freeConstraint(remC);\n            \n            const lastC = rope.constraintIndices[rope.constraintIndices.length-1]; \n            const prev = rope.indices[rope.indices.length-2];\n            this.setDistConstraint(lastC, prev, tail, SEG, CONFIG.ROPE_COMPLIANCE); \n            rope.segments--; \n            this.syncGPU();\n        }\n    }\n\n    spawnBall(pos: THREE.Vector2, bodyType: 'dynamic' | 'static' | 'kinematic' = 'dynamic', radius = 0.5, mass = 10.0) {\n        const idx = this.allocParticle(); if (idx===-1) return -1;\n        const invMass = bodyType === 'dynamic' ? 1.0 / mass : 0;\n        this.setParticle(idx, pos, invMass); \n        this.particles[idx*8+7] = radius;\n        this.syncGPU();\n        return idx;\n    }\n}\n"
    },
    {
      "filename": "tsconfig.json",
      "content": "{\n  \"compilerOptions\": {\n    // Environment setup & latest features\n    \"lib\": [\"ESNext\", \"DOM\", \"DOM.Iterable\", \"WebWorker\"],\n    \"target\": \"ESNext\",\n    \"module\": \"Preserve\",\n    \"moduleDetection\": \"force\",\n    \"jsx\": \"react-jsx\",\n    \"allowJs\": true,\n\n    // Bundler mode\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"verbatimModuleSyntax\": true,\n    \"noEmit\": true,\n\n    // Best practices\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"noImplicitOverride\": true,\n\n    // Some stricter flags (disabled by default)\n    \"noUnusedLocals\": false,\n    \"noUnusedParameters\": false,\n    \"noPropertyAccessFromIndexSignature\": false\n  }\n}\n"
    },
    {
      "filename": "vite.config.js",
      "content": "import { defineConfig } from 'vite';\n\nexport default defineConfig({\n  server: {\n    port: 3000,\n    open: true\n  },\n  assetsInclude: ['**/*.wgsl'],\n  build: {\n    target: 'esnext'\n  },\n  optimizeDeps: {\n    esbuildOptions: {\n      target: 'esnext'\n    },\n    include: ['three']\n  },\n  resolve: {\n    alias: {\n      'three/webgpu': 'three/src/renderers/webgpu/WebGPURenderer.js'\n    }\n  }\n});"
    }
  ]
}