{
  "version": "0.0.67",
  "files": [
    {
      "filename": "README.md",
      "content": "# spider-web-physics\n\nTo install dependencies:\n\n```bash\nbun install\n```\n\nTo run:\n\n```bash\nbun run \n```\n\nThis project was created using `bun init` in bun v1.3.9. [Bun](https://bun.com) is a fast all-in-one JavaScript runtime.\n"
    },
    {
      "filename": "bun.lock",
      "content": "{\n  \"lockfileVersion\": 1,\n  \"configVersion\": 1,\n  \"workspaces\": {\n    \"\": {\n      \"name\": \"spider-web-physics\",\n      \"dependencies\": {\n        \"@webgpu/types\": \"^0.1.43\",\n        \"three\": \"^0.183.0\",\n      },\n      \"devDependencies\": {\n        \"@types/bun\": \"latest\",\n        \"@types/three\": \"^0.182.0\",\n        \"typescript\": \"^5.3.0\",\n        \"vite\": \"^5.0.0\",\n      },\n      \"peerDependencies\": {\n        \"typescript\": \"^5\",\n      },\n    },\n  },\n  \"packages\": {\n    \"@dimforge/rapier3d-compat\": [\"@dimforge/rapier3d-compat@0.12.0\", \"\", {}, \"sha512-uekIGetywIgopfD97oDL5PfeezkFpNhwlzlaEYNOA0N6ghdsOvh/HYjSMek5Q2O1PYvRSDFcqFVJl4r4ZBwOow==\"],\n\n    \"@esbuild/aix-ppc64\": [\"@esbuild/aix-ppc64@0.21.5\", \"\", { \"os\": \"aix\", \"cpu\": \"ppc64\" }, \"sha512-1SDgH6ZSPTlggy1yI6+Dbkiz8xzpHJEVAlF/AM1tHPLsf5STom9rwtjE4hKAF20FfXXNTFqEYXyJNWh1GiZedQ==\"],\n\n    \"@esbuild/android-arm\": [\"@esbuild/android-arm@0.21.5\", \"\", { \"os\": \"android\", \"cpu\": \"arm\" }, \"sha512-vCPvzSjpPHEi1siZdlvAlsPxXl7WbOVUBBAowWug4rJHb68Ox8KualB+1ocNvT5fjv6wpkX6o/iEpbDrf68zcg==\"],\n\n    \"@esbuild/android-arm64\": [\"@esbuild/android-arm64@0.21.5\", \"\", { \"os\": \"android\", \"cpu\": \"arm64\" }, \"sha512-c0uX9VAUBQ7dTDCjq+wdyGLowMdtR/GoC2U5IYk/7D1H1JYC0qseD7+11iMP2mRLN9RcCMRcjC4YMclCzGwS/A==\"],\n\n    \"@esbuild/android-x64\": [\"@esbuild/android-x64@0.21.5\", \"\", { \"os\": \"android\", \"cpu\": \"x64\" }, \"sha512-D7aPRUUNHRBwHxzxRvp856rjUHRFW1SdQATKXH2hqA0kAZb1hKmi02OpYRacl0TxIGz/ZmXWlbZgjwWYaCakTA==\"],\n\n    \"@esbuild/darwin-arm64\": [\"@esbuild/darwin-arm64@0.21.5\", \"\", { \"os\": \"darwin\", \"cpu\": \"arm64\" }, \"sha512-DwqXqZyuk5AiWWf3UfLiRDJ5EDd49zg6O9wclZ7kUMv2WRFr4HKjXp/5t8JZ11QbQfUS6/cRCKGwYhtNAY88kQ==\"],\n\n    \"@esbuild/darwin-x64\": [\"@esbuild/darwin-x64@0.21.5\", \"\", { \"os\": \"darwin\", \"cpu\": \"x64\" }, \"sha512-se/JjF8NlmKVG4kNIuyWMV/22ZaerB+qaSi5MdrXtd6R08kvs2qCN4C09miupktDitvh8jRFflwGFBQcxZRjbw==\"],\n\n    \"@esbuild/freebsd-arm64\": [\"@esbuild/freebsd-arm64@0.21.5\", \"\", { \"os\": \"freebsd\", \"cpu\": \"arm64\" }, \"sha512-5JcRxxRDUJLX8JXp/wcBCy3pENnCgBR9bN6JsY4OmhfUtIHe3ZW0mawA7+RDAcMLrMIZaf03NlQiX9DGyB8h4g==\"],\n\n    \"@esbuild/freebsd-x64\": [\"@esbuild/freebsd-x64@0.21.5\", \"\", { \"os\": \"freebsd\", \"cpu\": \"x64\" }, \"sha512-J95kNBj1zkbMXtHVH29bBriQygMXqoVQOQYA+ISs0/2l3T9/kj42ow2mpqerRBxDJnmkUDCaQT/dfNXWX/ZZCQ==\"],\n\n    \"@esbuild/linux-arm\": [\"@esbuild/linux-arm@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"arm\" }, \"sha512-bPb5AHZtbeNGjCKVZ9UGqGwo8EUu4cLq68E95A53KlxAPRmUyYv2D6F0uUI65XisGOL1hBP5mTronbgo+0bFcA==\"],\n\n    \"@esbuild/linux-arm64\": [\"@esbuild/linux-arm64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"arm64\" }, \"sha512-ibKvmyYzKsBeX8d8I7MH/TMfWDXBF3db4qM6sy+7re0YXya+K1cem3on9XgdT2EQGMu4hQyZhan7TeQ8XkGp4Q==\"],\n\n    \"@esbuild/linux-ia32\": [\"@esbuild/linux-ia32@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"ia32\" }, \"sha512-YvjXDqLRqPDl2dvRODYmmhz4rPeVKYvppfGYKSNGdyZkA01046pLWyRKKI3ax8fbJoK5QbxblURkwK/MWY18Tg==\"],\n\n    \"@esbuild/linux-loong64\": [\"@esbuild/linux-loong64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-uHf1BmMG8qEvzdrzAqg2SIG/02+4/DHB6a9Kbya0XDvwDEKCoC8ZRWI5JJvNdUjtciBGFQ5PuBlpEOXQj+JQSg==\"],\n\n    \"@esbuild/linux-mips64el\": [\"@esbuild/linux-mips64el@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-IajOmO+KJK23bj52dFSNCMsz1QP1DqM6cwLUv3W1QwyxkyIWecfafnI555fvSGqEKwjMXVLokcV5ygHW5b3Jbg==\"],\n\n    \"@esbuild/linux-ppc64\": [\"@esbuild/linux-ppc64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"ppc64\" }, \"sha512-1hHV/Z4OEfMwpLO8rp7CvlhBDnjsC3CttJXIhBi+5Aj5r+MBvy4egg7wCbe//hSsT+RvDAG7s81tAvpL2XAE4w==\"],\n\n    \"@esbuild/linux-riscv64\": [\"@esbuild/linux-riscv64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-2HdXDMd9GMgTGrPWnJzP2ALSokE/0O5HhTUvWIbD3YdjME8JwvSCnNGBnTThKGEB91OZhzrJ4qIIxk/SBmyDDA==\"],\n\n    \"@esbuild/linux-s390x\": [\"@esbuild/linux-s390x@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"s390x\" }, \"sha512-zus5sxzqBJD3eXxwvjN1yQkRepANgxE9lgOW2qLnmr8ikMTphkjgXu1HR01K4FJg8h1kEEDAqDcZQtbrRnB41A==\"],\n\n    \"@esbuild/linux-x64\": [\"@esbuild/linux-x64@0.21.5\", \"\", { \"os\": \"linux\", \"cpu\": \"x64\" }, \"sha512-1rYdTpyv03iycF1+BhzrzQJCdOuAOtaqHTWJZCWvijKD2N5Xu0TtVC8/+1faWqcP9iBCWOmjmhoH94dH82BxPQ==\"],\n\n    \"@esbuild/netbsd-x64\": [\"@esbuild/netbsd-x64@0.21.5\", \"\", { \"os\": \"none\", \"cpu\": \"x64\" }, \"sha512-Woi2MXzXjMULccIwMnLciyZH4nCIMpWQAs049KEeMvOcNADVxo0UBIQPfSmxB3CWKedngg7sWZdLvLczpe0tLg==\"],\n\n    \"@esbuild/openbsd-x64\": [\"@esbuild/openbsd-x64@0.21.5\", \"\", { \"os\": \"openbsd\", \"cpu\": \"x64\" }, \"sha512-HLNNw99xsvx12lFBUwoT8EVCsSvRNDVxNpjZ7bPn947b8gJPzeHWyNVhFsaerc0n3TsbOINvRP2byTZ5LKezow==\"],\n\n    \"@esbuild/sunos-x64\": [\"@esbuild/sunos-x64@0.21.5\", \"\", { \"os\": \"sunos\", \"cpu\": \"x64\" }, \"sha512-6+gjmFpfy0BHU5Tpptkuh8+uw3mnrvgs+dSPQXQOv3ekbordwnzTVEb4qnIvQcYXq6gzkyTnoZ9dZG+D4garKg==\"],\n\n    \"@esbuild/win32-arm64\": [\"@esbuild/win32-arm64@0.21.5\", \"\", { \"os\": \"win32\", \"cpu\": \"arm64\" }, \"sha512-Z0gOTd75VvXqyq7nsl93zwahcTROgqvuAcYDUr+vOv8uHhNSKROyU961kgtCD1e95IqPKSQKH7tBTslnS3tA8A==\"],\n\n    \"@esbuild/win32-ia32\": [\"@esbuild/win32-ia32@0.21.5\", \"\", { \"os\": \"win32\", \"cpu\": \"ia32\" }, \"sha512-SWXFF1CL2RVNMaVs+BBClwtfZSvDgtL//G/smwAc5oVK/UPu2Gu9tIaRgFmYFFKrmg3SyAjSrElf0TiJ1v8fYA==\"],\n\n    \"@esbuild/win32-x64\": [\"@esbuild/win32-x64@0.21.5\", \"\", { \"os\": \"win32\", \"cpu\": \"x64\" }, \"sha512-tQd/1efJuzPC6rCFwEvLtci/xNFcTZknmXs98FYDfGE4wP9ClFV98nyKrzJKVPMhdDnjzLhdUyMX4PsQAPjwIw==\"],\n\n    \"@rollup/rollup-android-arm-eabi\": [\"@rollup/rollup-android-arm-eabi@4.57.1\", \"\", { \"os\": \"android\", \"cpu\": \"arm\" }, \"sha512-A6ehUVSiSaaliTxai040ZpZ2zTevHYbvu/lDoeAteHI8QnaosIzm4qwtezfRg1jOYaUmnzLX1AOD6Z+UJjtifg==\"],\n\n    \"@rollup/rollup-android-arm64\": [\"@rollup/rollup-android-arm64@4.57.1\", \"\", { \"os\": \"android\", \"cpu\": \"arm64\" }, \"sha512-dQaAddCY9YgkFHZcFNS/606Exo8vcLHwArFZ7vxXq4rigo2bb494/xKMMwRRQW6ug7Js6yXmBZhSBRuBvCCQ3w==\"],\n\n    \"@rollup/rollup-darwin-arm64\": [\"@rollup/rollup-darwin-arm64@4.57.1\", \"\", { \"os\": \"darwin\", \"cpu\": \"arm64\" }, \"sha512-crNPrwJOrRxagUYeMn/DZwqN88SDmwaJ8Cvi/TN1HnWBU7GwknckyosC2gd0IqYRsHDEnXf328o9/HC6OkPgOg==\"],\n\n    \"@rollup/rollup-darwin-x64\": [\"@rollup/rollup-darwin-x64@4.57.1\", \"\", { \"os\": \"darwin\", \"cpu\": \"x64\" }, \"sha512-Ji8g8ChVbKrhFtig5QBV7iMaJrGtpHelkB3lsaKzadFBe58gmjfGXAOfI5FV0lYMH8wiqsxKQ1C9B0YTRXVy4w==\"],\n\n    \"@rollup/rollup-freebsd-arm64\": [\"@rollup/rollup-freebsd-arm64@4.57.1\", \"\", { \"os\": \"freebsd\", \"cpu\": \"arm64\" }, \"sha512-R+/WwhsjmwodAcz65guCGFRkMb4gKWTcIeLy60JJQbXrJ97BOXHxnkPFrP+YwFlaS0m+uWJTstrUA9o+UchFug==\"],\n\n    \"@rollup/rollup-freebsd-x64\": [\"@rollup/rollup-freebsd-x64@4.57.1\", \"\", { \"os\": \"freebsd\", \"cpu\": \"x64\" }, \"sha512-IEQTCHeiTOnAUC3IDQdzRAGj3jOAYNr9kBguI7MQAAZK3caezRrg0GxAb6Hchg4lxdZEI5Oq3iov/w/hnFWY9Q==\"],\n\n    \"@rollup/rollup-linux-arm-gnueabihf\": [\"@rollup/rollup-linux-arm-gnueabihf@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"arm\" }, \"sha512-F8sWbhZ7tyuEfsmOxwc2giKDQzN3+kuBLPwwZGyVkLlKGdV1nvnNwYD0fKQ8+XS6hp9nY7B+ZeK01EBUE7aHaw==\"],\n\n    \"@rollup/rollup-linux-arm-musleabihf\": [\"@rollup/rollup-linux-arm-musleabihf@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"arm\" }, \"sha512-rGfNUfn0GIeXtBP1wL5MnzSj98+PZe/AXaGBCRmT0ts80lU5CATYGxXukeTX39XBKsxzFpEeK+Mrp9faXOlmrw==\"],\n\n    \"@rollup/rollup-linux-arm64-gnu\": [\"@rollup/rollup-linux-arm64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"arm64\" }, \"sha512-MMtej3YHWeg/0klK2Qodf3yrNzz6CGjo2UntLvk2RSPlhzgLvYEB3frRvbEF2wRKh1Z2fDIg9KRPe1fawv7C+g==\"],\n\n    \"@rollup/rollup-linux-arm64-musl\": [\"@rollup/rollup-linux-arm64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"arm64\" }, \"sha512-1a/qhaaOXhqXGpMFMET9VqwZakkljWHLmZOX48R0I/YLbhdxr1m4gtG1Hq7++VhVUmf+L3sTAf9op4JlhQ5u1Q==\"],\n\n    \"@rollup/rollup-linux-loong64-gnu\": [\"@rollup/rollup-linux-loong64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-QWO6RQTZ/cqYtJMtxhkRkidoNGXc7ERPbZN7dVW5SdURuLeVU7lwKMpo18XdcmpWYd0qsP1bwKPf7DNSUinhvA==\"],\n\n    \"@rollup/rollup-linux-loong64-musl\": [\"@rollup/rollup-linux-loong64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-xpObYIf+8gprgWaPP32xiN5RVTi/s5FCR+XMXSKmhfoJjrpRAjCuuqQXyxUa/eJTdAE6eJ+KDKaoEqjZQxh3Gw==\"],\n\n    \"@rollup/rollup-linux-ppc64-gnu\": [\"@rollup/rollup-linux-ppc64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"ppc64\" }, \"sha512-4BrCgrpZo4hvzMDKRqEaW1zeecScDCR+2nZ86ATLhAoJ5FQ+lbHVD3ttKe74/c7tNT9c6F2viwB3ufwp01Oh2w==\"],\n\n    \"@rollup/rollup-linux-ppc64-musl\": [\"@rollup/rollup-linux-ppc64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"ppc64\" }, \"sha512-NOlUuzesGauESAyEYFSe3QTUguL+lvrN1HtwEEsU2rOwdUDeTMJdO5dUYl/2hKf9jWydJrO9OL/XSSf65R5+Xw==\"],\n\n    \"@rollup/rollup-linux-riscv64-gnu\": [\"@rollup/rollup-linux-riscv64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-ptA88htVp0AwUUqhVghwDIKlvJMD/fmL/wrQj99PRHFRAG6Z5nbWoWG4o81Nt9FT+IuqUQi+L31ZKAFeJ5Is+A==\"],\n\n    \"@rollup/rollup-linux-riscv64-musl\": [\"@rollup/rollup-linux-riscv64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"none\" }, \"sha512-S51t7aMMTNdmAMPpBg7OOsTdn4tySRQvklmL3RpDRyknk87+Sp3xaumlatU+ppQ+5raY7sSTcC2beGgvhENfuw==\"],\n\n    \"@rollup/rollup-linux-s390x-gnu\": [\"@rollup/rollup-linux-s390x-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"s390x\" }, \"sha512-Bl00OFnVFkL82FHbEqy3k5CUCKH6OEJL54KCyx2oqsmZnFTR8IoNqBF+mjQVcRCT5sB6yOvK8A37LNm/kPJiZg==\"],\n\n    \"@rollup/rollup-linux-x64-gnu\": [\"@rollup/rollup-linux-x64-gnu@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"x64\" }, \"sha512-ABca4ceT4N+Tv/GtotnWAeXZUZuM/9AQyCyKYyKnpk4yoA7QIAuBt6Hkgpw8kActYlew2mvckXkvx0FfoInnLg==\"],\n\n    \"@rollup/rollup-linux-x64-musl\": [\"@rollup/rollup-linux-x64-musl@4.57.1\", \"\", { \"os\": \"linux\", \"cpu\": \"x64\" }, \"sha512-HFps0JeGtuOR2convgRRkHCekD7j+gdAuXM+/i6kGzQtFhlCtQkpwtNzkNj6QhCDp7DRJ7+qC/1Vg2jt5iSOFw==\"],\n\n    \"@rollup/rollup-openbsd-x64\": [\"@rollup/rollup-openbsd-x64@4.57.1\", \"\", { \"os\": \"openbsd\", \"cpu\": \"x64\" }, \"sha512-H+hXEv9gdVQuDTgnqD+SQffoWoc0Of59AStSzTEj/feWTBAnSfSD3+Dql1ZruJQxmykT/JVY0dE8Ka7z0DH1hw==\"],\n\n    \"@rollup/rollup-openharmony-arm64\": [\"@rollup/rollup-openharmony-arm64@4.57.1\", \"\", { \"os\": \"none\", \"cpu\": \"arm64\" }, \"sha512-4wYoDpNg6o/oPximyc/NG+mYUejZrCU2q+2w6YZqrAs2UcNUChIZXjtafAiiZSUc7On8v5NyNj34Kzj/Ltk6dQ==\"],\n\n    \"@rollup/rollup-win32-arm64-msvc\": [\"@rollup/rollup-win32-arm64-msvc@4.57.1\", \"\", { \"os\": \"win32\", \"cpu\": \"arm64\" }, \"sha512-O54mtsV/6LW3P8qdTcamQmuC990HDfR71lo44oZMZlXU4tzLrbvTii87Ni9opq60ds0YzuAlEr/GNwuNluZyMQ==\"],\n\n    \"@rollup/rollup-win32-ia32-msvc\": [\"@rollup/rollup-win32-ia32-msvc@4.57.1\", \"\", { \"os\": \"win32\", \"cpu\": \"ia32\" }, \"sha512-P3dLS+IerxCT/7D2q2FYcRdWRl22dNbrbBEtxdWhXrfIMPP9lQhb5h4Du04mdl5Woq05jVCDPCMF7Ub0NAjIew==\"],\n\n    \"@rollup/rollup-win32-x64-gnu\": [\"@rollup/rollup-win32-x64-gnu@4.57.1\", \"\", { \"os\": \"win32\", \"cpu\": \"x64\" }, \"sha512-VMBH2eOOaKGtIJYleXsi2B8CPVADrh+TyNxJ4mWPnKfLB/DBUmzW+5m1xUrcwWoMfSLagIRpjUFeW5CO5hyciQ==\"],\n\n    \"@rollup/rollup-win32-x64-msvc\": [\"@rollup/rollup-win32-x64-msvc@4.57.1\", \"\", { \"os\": \"win32\", \"cpu\": \"x64\" }, \"sha512-mxRFDdHIWRxg3UfIIAwCm6NzvxG0jDX/wBN6KsQFTvKFqqg9vTrWUE68qEjHt19A5wwx5X5aUi2zuZT7YR0jrA==\"],\n\n    \"@tweenjs/tween.js\": [\"@tweenjs/tween.js@23.1.3\", \"\", {}, \"sha512-vJmvvwFxYuGnF2axRtPYocag6Clbb5YS7kLL+SO/TeVFzHqDIWrNKYtcsPMibjDx9O+bu+psAy9NKfWklassUA==\"],\n\n    \"@types/bun\": [\"@types/bun@1.3.9\", \"\", { \"dependencies\": { \"bun-types\": \"1.3.9\" } }, \"sha512-KQ571yULOdWJiMH+RIWIOZ7B2RXQGpL1YQrBtLIV3FqDcCu6FsbFUBwhdKUlCKUpS3PJDsHlJ1QKlpxoVR+xtw==\"],\n\n    \"@types/estree\": [\"@types/estree@1.0.8\", \"\", {}, \"sha512-dWHzHa2WqEXI/O1E9OjrocMTKJl2mSrEolh1Iomrv6U+JuNwaHXsXx9bLu5gG7BUWFIN0skIQJQ/L1rIex4X6w==\"],\n\n    \"@types/node\": [\"@types/node@25.2.3\", \"\", { \"dependencies\": { \"undici-types\": \"~7.16.0\" } }, \"sha512-m0jEgYlYz+mDJZ2+F4v8D1AyQb+QzsNqRuI7xg1VQX/KlKS0qT9r1Mo16yo5F/MtifXFgaofIFsdFMox2SxIbQ==\"],\n\n    \"@types/stats.js\": [\"@types/stats.js@0.17.4\", \"\", {}, \"sha512-jIBvWWShCvlBqBNIZt0KAshWpvSjhkwkEu4ZUcASoAvhmrgAUI2t1dXrjSL4xXVLB4FznPrIsX3nKXFl/Dt4vA==\"],\n\n    \"@types/three\": [\"@types/three@0.182.0\", \"\", { \"dependencies\": { \"@dimforge/rapier3d-compat\": \"~0.12.0\", \"@tweenjs/tween.js\": \"~23.1.3\", \"@types/stats.js\": \"*\", \"@types/webxr\": \">=0.5.17\", \"@webgpu/types\": \"*\", \"fflate\": \"~0.8.2\", \"meshoptimizer\": \"~0.22.0\" } }, \"sha512-WByN9V3Sbwbe2OkWuSGyoqQO8Du6yhYaXtXLoA5FkKTUJorZ+yOHBZ35zUUPQXlAKABZmbYp5oAqpA4RBjtJ/Q==\"],\n\n    \"@types/webxr\": [\"@types/webxr@0.5.24\", \"\", {}, \"sha512-h8fgEd/DpoS9CBrjEQXR+dIDraopAEfu4wYVNY2tEPwk60stPWhvZMf4Foo5FakuQ7HFZoa8WceaWFervK2Ovg==\"],\n\n    \"@webgpu/types\": [\"@webgpu/types@0.1.69\", \"\", {}, \"sha512-RPmm6kgRbI8e98zSD3RVACvnuktIja5+yLgDAkTmxLr90BEwdTXRQWNLF3ETTTyH/8mKhznZuN5AveXYFEsMGQ==\"],\n\n    \"bun-types\": [\"bun-types@1.3.9\", \"\", { \"dependencies\": { \"@types/node\": \"*\" } }, \"sha512-+UBWWOakIP4Tswh0Bt0QD0alpTY8cb5hvgiYeWCMet9YukHbzuruIEeXC2D7nMJPB12kbh8C7XJykSexEqGKJg==\"],\n\n    \"esbuild\": [\"esbuild@0.21.5\", \"\", { \"optionalDependencies\": { \"@esbuild/aix-ppc64\": \"0.21.5\", \"@esbuild/android-arm\": \"0.21.5\", \"@esbuild/android-arm64\": \"0.21.5\", \"@esbuild/android-x64\": \"0.21.5\", \"@esbuild/darwin-arm64\": \"0.21.5\", \"@esbuild/darwin-x64\": \"0.21.5\", \"@esbuild/freebsd-arm64\": \"0.21.5\", \"@esbuild/freebsd-x64\": \"0.21.5\", \"@esbuild/linux-arm\": \"0.21.5\", \"@esbuild/linux-arm64\": \"0.21.5\", \"@esbuild/linux-ia32\": \"0.21.5\", \"@esbuild/linux-loong64\": \"0.21.5\", \"@esbuild/linux-mips64el\": \"0.21.5\", \"@esbuild/linux-ppc64\": \"0.21.5\", \"@esbuild/linux-riscv64\": \"0.21.5\", \"@esbuild/linux-s390x\": \"0.21.5\", \"@esbuild/linux-x64\": \"0.21.5\", \"@esbuild/netbsd-x64\": \"0.21.5\", \"@esbuild/openbsd-x64\": \"0.21.5\", \"@esbuild/sunos-x64\": \"0.21.5\", \"@esbuild/win32-arm64\": \"0.21.5\", \"@esbuild/win32-ia32\": \"0.21.5\", \"@esbuild/win32-x64\": \"0.21.5\" }, \"bin\": { \"esbuild\": \"bin/esbuild\" } }, \"sha512-mg3OPMV4hXywwpoDxu3Qda5xCKQi+vCTZq8S9J/EpkhB2HzKXq4SNFZE3+NK93JYxc8VMSep+lOUSC/RVKaBqw==\"],\n\n    \"fflate\": [\"fflate@0.8.2\", \"\", {}, \"sha512-cPJU47OaAoCbg0pBvzsgpTPhmhqI5eJjh/JIu8tPj5q+T7iLvW/JAYUqmE7KOB4R1ZyEhzBaIQpQpardBF5z8A==\"],\n\n    \"fsevents\": [\"fsevents@2.3.3\", \"\", { \"os\": \"darwin\" }, \"sha512-5xoDfX+fL7faATnagmWPpbFtwh/R77WmMMqqHGS65C3vvB0YHrgF+B1YmZ3441tMj5n63k0212XNoJwzlhffQw==\"],\n\n    \"meshoptimizer\": [\"meshoptimizer@0.22.0\", \"\", {}, \"sha512-IebiK79sqIy+E4EgOr+CAw+Ke8hAspXKzBd0JdgEmPHiAwmvEj2S4h1rfvo+o/BnfEYd/jAOg5IeeIjzlzSnDg==\"],\n\n    \"nanoid\": [\"nanoid@3.3.11\", \"\", { \"bin\": { \"nanoid\": \"bin/nanoid.cjs\" } }, \"sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==\"],\n\n    \"picocolors\": [\"picocolors@1.1.1\", \"\", {}, \"sha512-xceH2snhtb5M9liqDsmEw56le376mTZkEX/jEb/RxNFyegNul7eNslCXP9FDj/Lcu0X8KEyMceP2ntpaHrDEVA==\"],\n\n    \"postcss\": [\"postcss@8.5.6\", \"\", { \"dependencies\": { \"nanoid\": \"^3.3.11\", \"picocolors\": \"^1.1.1\", \"source-map-js\": \"^1.2.1\" } }, \"sha512-3Ybi1tAuwAP9s0r1UQ2J4n5Y0G05bJkpUIO0/bI9MhwmD70S5aTWbXGBwxHrelT+XM1k6dM0pk+SwNkpTRN7Pg==\"],\n\n    \"rollup\": [\"rollup@4.57.1\", \"\", { \"dependencies\": { \"@types/estree\": \"1.0.8\" }, \"optionalDependencies\": { \"@rollup/rollup-android-arm-eabi\": \"4.57.1\", \"@rollup/rollup-android-arm64\": \"4.57.1\", \"@rollup/rollup-darwin-arm64\": \"4.57.1\", \"@rollup/rollup-darwin-x64\": \"4.57.1\", \"@rollup/rollup-freebsd-arm64\": \"4.57.1\", \"@rollup/rollup-freebsd-x64\": \"4.57.1\", \"@rollup/rollup-linux-arm-gnueabihf\": \"4.57.1\", \"@rollup/rollup-linux-arm-musleabihf\": \"4.57.1\", \"@rollup/rollup-linux-arm64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-arm64-musl\": \"4.57.1\", \"@rollup/rollup-linux-loong64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-loong64-musl\": \"4.57.1\", \"@rollup/rollup-linux-ppc64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-ppc64-musl\": \"4.57.1\", \"@rollup/rollup-linux-riscv64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-riscv64-musl\": \"4.57.1\", \"@rollup/rollup-linux-s390x-gnu\": \"4.57.1\", \"@rollup/rollup-linux-x64-gnu\": \"4.57.1\", \"@rollup/rollup-linux-x64-musl\": \"4.57.1\", \"@rollup/rollup-openbsd-x64\": \"4.57.1\", \"@rollup/rollup-openharmony-arm64\": \"4.57.1\", \"@rollup/rollup-win32-arm64-msvc\": \"4.57.1\", \"@rollup/rollup-win32-ia32-msvc\": \"4.57.1\", \"@rollup/rollup-win32-x64-gnu\": \"4.57.1\", \"@rollup/rollup-win32-x64-msvc\": \"4.57.1\", \"fsevents\": \"~2.3.2\" }, \"bin\": { \"rollup\": \"dist/bin/rollup\" } }, \"sha512-oQL6lgK3e2QZeQ7gcgIkS2YZPg5slw37hYufJ3edKlfQSGGm8ICoxswK15ntSzF/a8+h7ekRy7k7oWc3BQ7y8A==\"],\n\n    \"source-map-js\": [\"source-map-js@1.2.1\", \"\", {}, \"sha512-UXWMKhLOwVKb728IUtQPXxfYU+usdybtUrK/8uGE8CQMvrhOpwvzDBwj0QhSL7MQc7vIsISBG8VQ8+IDQxpfQA==\"],\n\n    \"three\": [\"three@0.183.0\", \"\", {}, \"sha512-G6SH2jfefIVa2YI4JL2VbgQhrrbp1A8dRc7lr3PW827kdVyaX2RgH6M5FmjmdVFLgSHppyg3OYOZdTfWElle+g==\"],\n\n    \"typescript\": [\"typescript@5.9.3\", \"\", { \"bin\": { \"tsc\": \"bin/tsc\", \"tsserver\": \"bin/tsserver\" } }, \"sha512-jl1vZzPDinLr9eUt3J/t7V6FgNEw9QjvBPdysz9KfQDD41fQrC2Y4vKQdiaUpFT4bXlb1RHhLpp8wtm6M5TgSw==\"],\n\n    \"undici-types\": [\"undici-types@7.16.0\", \"\", {}, \"sha512-Zz+aZWSj8LE6zoxD+xrjh4VfkIG8Ya6LvYkZqtUQGJPZjYl53ypCaUwWqo7eI0x66KBGeRo+mlBEkMSeSZ38Nw==\"],\n\n    \"vite\": [\"vite@5.4.21\", \"\", { \"dependencies\": { \"esbuild\": \"^0.21.3\", \"postcss\": \"^8.4.43\", \"rollup\": \"^4.20.0\" }, \"optionalDependencies\": { \"fsevents\": \"~2.3.3\" }, \"peerDependencies\": { \"@types/node\": \"^18.0.0 || >=20.0.0\", \"less\": \"*\", \"lightningcss\": \"^1.21.0\", \"sass\": \"*\", \"sass-embedded\": \"*\", \"stylus\": \"*\", \"sugarss\": \"*\", \"terser\": \"^5.4.0\" }, \"optionalPeers\": [\"@types/node\", \"less\", \"lightningcss\", \"sass\", \"sass-embedded\", \"stylus\", \"sugarss\", \"terser\"], \"bin\": { \"vite\": \"bin/vite.js\" } }, \"sha512-o5a9xKjbtuhY6Bi5S3+HvbRERmouabWbyUcpXXUA1u+GNUKoROi9byOJ8M0nHbHYHkYICiMlqxkg1KkYmm25Sw==\"],\n  }\n}\n"
    },
    {
      "filename": "index.html",
      "content": "<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>Spider Web Physics Prototype</title>\n    <style>\n        body { margin: 0; overflow: hidden; background: #111; color: white; font-family: sans-serif; }\n        #ui { position: absolute; top: 10px; left: 10px; pointer-events: none; z-index: 10; }\n        .warning { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: #333; padding: 20px; border-radius: 8px; text-align: center; z-index: 100; }\n        .warning.show { display: block; }\n    </style>\n</head>\n<body>\n    <div id=\"ui\">\n        WASD: Move on walls | Space: Jump | E: Pin | Current State: <span id=\"state\">START</span>\n    </div>\n    <div id=\"warning\" class=\"warning\">\n        <h2>WebGPU niedostępna</h2>\n        <p>Wymagany Chrome/Edge 113+, Opera 99+ lub Firefox Nightly</p>\n    </div>\n    <script type=\"module\" src=\"/src/main.ts\"></script>\n</body>\n</html>"
    },
    {
      "filename": "mvp.md",
      "content": "Oto definicja MVP dla Twojej gry „Web-Builder 2D” na WebGPU:\n1. Świat Gry (Środowisko)\nProstokątne „Akwarium”: Granice ekranu stanowią twarde kolizje.\nWektor Wiatru: Globalna zmienna uniform vec2 windForce, która co klatkę dodaje siłę do każdego wolnego węzła.\n2. Fizyka (Compute Shader / PBD)\nUżyjemy Position Based Dynamics, bo jest najbardziej stabilne dla sznurków i WebGPU.\nBufor Punktów (Particles): Każdy punkt ma: position, old_position, mass (0 dla punktów przytwierdzonych).\nBufor Wiązań (Constraints): Indeks punktu A, indeks punktu B, rest_length (długość spoczynkowa).\nKrok Fizyki:\nAplikacja wiatru i grawitacji (nowa pozycja).\nRozwiązanie wiązań (pętla iteracyjna – pociąganie punktów ku sobie, by zachować rest_length).\nKolizja ze ścianami (jeśli pos.x < 0, to pos.x = 0).\n3. Pająk (Gracz) – Logika i Sterowanie\nPająk jest specjalnym „super-węzłem” w systemie fizycznym. Ma dwa stany:\nA. Stan: Chodzenie (On Wall/Ceiling)\nPająk jest „przyklejony” do ściany (jego masa w shaderze = 0, lub ignorujemy siły zewnętrzne).\nRuch: Zmieniamy jego współrzędne bezpośrednio na podstawie klawiszy (L/P/G/D).\nJump: Odlepia pająka od ściany, nadaje mu prędkość początkową i zmienia stan na IN_AIR.\nB. Stan: Wiszenie/Lot (In Air)\nPająk staje się zwykłym punktem fizycznym podlegającym grawitacji i wiatrowi.\nWytwarzanie liny: Jeśli pająk skacze, automatycznie tworzy się pierwsze wiązanie między punktem na ścianie (kotwicą) a pająkiem.\n4. Mechanika Liny (Dynamiczne Wiązania)\nTo jest serce gry. Musisz zarządzać listą węzłów liny, którą pająk „rozwija”.\nRozwijanie: Jeśli pająk oddali się od ostatniego węzła o więcej niż X metrów, shader/skrypt dodaje nowy węzeł w miejscu pająka i tworzy nowe wiązanie między pająkiem a tym nowym węzłem.\nZwijanie/Rozwijanie (Góra/Dół):\nZamiast dodawać węzły, zmieniasz parametr rest_length ostatniego odcinka (tego przy pająku).\nJeśli rest_length spadnie do 0 – usuwasz segment.\nJeśli wzrośnie powyżej limitu – dodajesz nowy segment.\nPrzypnij (Pin): Kiedy pająk dotknie dowolnej ściany podczas wiszenia na linie, ostatni węzeł (przy pająku) zostaje zamieniony na „kotwicę” (masa = 0). Lina zostaje w świecie, a pająk jest wolny.\n5. Technologia (WebGPU + Three.js)\nCompute Shader: Liczy wszystkie Constraints i Particle Positions.\nThree.js: Używamy InstancedMesh (dla małych kulek-węzłów) oraz LineSegments do wizualizacji nici.\nProTip: WebGPU pozwala na Storage Buffer sharing. Oznacza to, że Compute Shader zapisuje pozycje prosto do bufora, który Three.js odczytuje jako bufor wierzchołków (Vertex Buffer) bez przesyłania danych przez CPU!\nScenariusz MVP (User Flow):\nPająk siedzi na lewej ścianie.\nGracz klika JUMP -> Pająk leci w prawo. Silnik tworzy „Kotwicę” na lewej ścianie i nitkę do pająka.\nPająk leci po łuku (wahadło). Gracz trzyma GÓRĘ -> lina się skraca, pająk podciąga się wyżej.\nPająk dolatuje do sufitu. Gracz klika PIN -> Nitka zostaje przymocowana do sufitu.\nMamy teraz nitkę rozpiętą między lewą ścianą a sufitem.\nPająk może teraz przejść po suficie i skoczyć z innego miejsca, budując kolejną nitkę."
    },
    {
      "filename": "package.json",
      "content": "{\n  \"name\": \"spider-web-physics\",\n  \"private\": true,\n  \"version\": \"0.0.67\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"dev\": \"vite\",\n    \"build\": \"vite build\",\n    \"preview\": \"vite preview\"\n  },\n  \"dependencies\": {\n    \"@webgpu/types\": \"^0.1.43\",\n    \"three\": \"^0.182.0\"\n  },\n  \"devDependencies\": {\n    \"@types/bun\": \"latest\",\n    \"@types/three\": \"^0.182.0\",\n    \"typescript\": \"^5.3.0\",\n    \"vite\": \"^5.0.0\"\n  },\n  \"peerDependencies\": {\n    \"typescript\": \"^5\"\n  }\n}\n"
    },
    {
      "filename": "requirements.md",
      "content": "# Web-Builder 2D Requirements\n\n## Functional Requirements\n- **Spider Movement (Wall/Ceiling):**\n  - Smooth movement along the 2D boundaries (Left, Right, Up, Down).\n  - Spider should automatically stick to walls/ceiling when touching them.\n- **Jump Mechanic:**\n  - Pressing Space detaches the spider from the wall.\n  - Initial velocity applied in the direction of the jump.\n- **Web Creation (Rope):**\n  - A line starts from the point where the spider jumped.\n  - The line follows the spider in the air.\n  - Rope length can be adjusted (Up/Down keys while in air).\n- **Pinning:**\n  - Pressing 'E' or touching another wall while in air attaches the current line permanently.\n- **Environment:**\n  - 2D rectangular box as boundaries.\n  - Constant gravity and a variable wind vector.\n\n## Technical Requirements\n- **Renderer:** Three.js using `WebGPURenderer`.\n- **Physics Engine:** Custom Compute Shader based on Position Based Dynamics (PBD).\n- **State Management:** Simple state machine for the spider (IDLE, CLIMBING, IN_AIR).\n- **Performance:** Target 60 FPS with thousands of rope segments using GPU buffers."
    },
    {
      "filename": "src/main.ts",
      "content": "import * as THREE from 'three';\n// @ts-ignore\nimport WebGPURenderer from 'three/src/renderers/webgpu/WebGPURenderer.js';\nimport { WebPhysics } from './webPhysics';\n\nlet scene: THREE.Scene, camera: THREE.OrthographicCamera, renderer: any, physics: WebPhysics, stateDisplay: HTMLSpanElement;\nlet activeRope: any = null;\nconst mouseWorld = new THREE.Vector2();\nconst BOUNDS = { width: 24, height: 14 };\n\nasync function init() {\n    if (!navigator.gpu) return;\n\n    stateDisplay = document.getElementById('state') as HTMLSpanElement;\n    scene = new THREE.Scene();\n    camera = new THREE.OrthographicCamera(-BOUNDS.width/2, BOUNDS.width/2, BOUNDS.height/2, -BOUNDS.height/2, 0.1, 1000);\n    camera.position.z = 10;\n    \n    renderer = new WebGPURenderer({ antialias: true });\n    renderer.setPixelRatio(window.devicePixelRatio);\n    renderer.setSize(window.innerWidth, window.innerHeight);\n    document.body.appendChild(renderer.domElement);\n\n    await renderer.init();\n\n    physics = new WebPhysics(renderer, scene, BOUNDS);\n    await physics.init();\n\n    // Visual Frame\n    const frameMat = new THREE.LineBasicMaterial({ color: 0x888888, linewidth: 2 });\n    const frameGeo = new THREE.EdgesGeometry(new THREE.BoxGeometry(BOUNDS.width - 0.2, BOUNDS.height - 0.2, 0));\n    scene.add(new THREE.LineSegments(frameGeo, frameMat));\n\n    // Obstacle visual\n    const circle = new THREE.Mesh(new THREE.CircleGeometry(1.5, 32), new THREE.MeshBasicMaterial({ color: 0x333333 }));\n    circle.position.set(4, 2, -1);\n    scene.add(circle);\n\n    window.addEventListener('mousedown', onMouseDown);\n    window.addEventListener('mousemove', onMouseMove);\n    window.addEventListener('wheel', onWheel);\n    window.addEventListener('keydown', onKeyDown);\n    window.addEventListener('resize', () => renderer.setSize(window.innerWidth, window.innerHeight));\n\n    animate();\n}\n\nfunction getMouseWorld(e: MouseEvent): THREE.Vector2 {\n    const x = (e.clientX / window.innerWidth) * 2 - 1;\n    const y = -(e.clientY / window.innerHeight) * 2 + 1;\n    return new THREE.Vector2(x * (BOUNDS.width / 2), y * (BOUNDS.height / 2));\n}\n\nfunction onMouseDown(e: MouseEvent) {\n    if (!physics.ready) return;\n    const pos = getMouseWorld(e);\n    const anchor = physics.findAnchor(pos);\n    \n    if (activeRope) {\n        if (anchor) {\n            physics.pinActiveRope(activeRope, anchor);\n            activeRope = null;\n        }\n    } else {\n        if (anchor) {\n            activeRope = physics.createRope(anchor);\n        }\n    }\n}\n\nfunction onMouseMove(e: MouseEvent) {\n    mouseWorld.copy(getMouseWorld(e));\n}\n\nfunction onWheel(e: WheelEvent) {\n    if (activeRope) {\n        // Standardizing wheel delta\n        const delta = e.deltaY / 100;\n        physics.adjustRopeLength(activeRope, delta);\n    }\n}\n\nfunction onKeyDown(e: KeyboardEvent) {\n    if (e.code === 'KeyQ') {\n        physics.spawnBall(mouseWorld);\n    }\n}\n\nfunction animate() {\n    requestAnimationFrame(animate);\n    if (physics.ready) {\n        physics.update(mouseWorld);\n    }\n    renderer.render(scene, camera);\n    \n    const anchor = physics.findAnchor(mouseWorld);\n    const canAnchor = anchor !== null;\n\n    if (activeRope) {\n        const color = canAnchor ? 0x00ff00 : 0xff0000;\n        activeRope.mesh.material.color.set(color);\n        activeRope.pointsMesh.material.color.set(color);\n    }\n\n    stateDisplay.innerText = `XPBD | Active: ${activeRope ? 'YES' : 'NO'} | Valid Anchor: ${canAnchor ? 'YES' : 'NO'} | Q: Spawn Ball`;\n}\n\ninit();"
    },
    {
      "filename": "src/physics.wgsl",
      "content": "struct Particle {\n    pos: vec2<f32>,\n    oldPos: vec2<f32>,\n    vel: vec2<f32>,\n    invMass: f32,\n    radius: f32,\n};\n\nstruct DistanceConstraint {\n    idxA: u32,\n    idxB: u32,\n    restLength: f32,\n    compliance: f32,\n};\n\nstruct Attachment {\n    pIdx: u32,\n    aIdx: u32,\n    bIdx: u32,\n    t: f32,\n};\n\nstruct Params {\n    dt: f32,\n    gravity: f32,\n    numParticles: u32,\n    numDistConstraints: u32,\n    substeps: u32,\n    phase: u32,\n    mousePos: vec2<f32>,\n    activeParticleIdx: i32,\n    numAttachments: u32,\n};\n\n@group(0) @binding(0) var<storage, read_write> particles: array<Particle>;\n@group(0) @binding(1) var<storage, read> distConstraints: array<DistanceConstraint>;\n@group(0) @binding(2) var<storage, read> attachments: array<Attachment>;\n@group(0) @binding(3) var<uniform> params: Params;\n\n@compute @workgroup_size(64)\nfn integrate(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x;\n    if (i >= params.numParticles) { return; }\n    \n    var p = particles[i];\n    if (abs(p.pos.x) > 1000.0 || abs(p.pos.y) > 1000.0) {\n        particles[i].pos = vec2<f32>(0.0, 0.0);\n        particles[i].oldPos = vec2<f32>(0.0, 0.0);\n        return;\n    }\n\n    if (i == u32(params.activeParticleIdx)) {\n        particles[i].pos = params.mousePos;\n        particles[i].oldPos = params.mousePos;\n        particles[i].vel = vec2<f32>(0.0);\n        return;\n    }\n\n    if (p.invMass <= 0.0) { return; }\n\n    let h = params.dt / f32(params.substeps);\n    var vel = (p.pos - p.oldPos) / h;\n    vel = vel * 0.999;\n    vel = vel + vec2<f32>(0.0, params.gravity) * h;\n\n    let nextPos = p.pos + vel * h;\n    particles[i].oldPos = p.pos;\n    particles[i].pos = nextPos;\n    particles[i].vel = vel;\n}\n\n@compute @workgroup_size(64)\nfn solveDistance(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x;\n    if (i >= params.numDistConstraints) { return; }\n    if (i % 2u != params.phase) { return; }\n    \n    let c = distConstraints[i];\n    let w1 = particles[c.idxA].invMass;\n    let w2 = particles[c.idxB].invMass;\n    let wSum = w1 + w2;\n    if (wSum <= 0.0) { return; }\n\n    let delta = particles[c.idxA].pos - particles[c.idxB].pos;\n    let dist = length(delta);\n    if (dist < 0.0001) { return; }\n\n    let h = params.dt / f32(params.substeps);\n    let alpha = c.compliance / (h * h);\n    let dLambda = -(dist - c.restLength) / (wSum + alpha);\n    \n    var correction = delta * (dLambda / dist);\n    if (w1 > 0.0) { particles[c.idxA].pos += correction * w1; }\n    if (w2 > 0.0) { particles[c.idxB].pos -= correction * w2; }\n}\n\n@compute @workgroup_size(64)\nfn solveAttachments(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x;\n    if (i >= params.numAttachments) { return; }\n    \n    let att = attachments[i];\n    let p = particles[att.pIdx].pos;\n    let a = particles[att.aIdx].pos;\n    let b = particles[att.bIdx].pos;\n    let link_target = mix(a, b, att.t);\n    let delta = p - link_target;\n    let dist = length(delta);\n    if (dist < 0.0001) { return; }\n\n    let wp = particles[att.pIdx].invMass;\n    let wa = particles[att.aIdx].invMass;\n    let wb = particles[att.bIdx].invMass;\n    let wSegment = wa * (1.0 - att.t) + wb * att.t;\n    let wSum = wp + wSegment;\n    if (wSum <= 0.0) { return; }\n\n    let dLambda = -dist / wSum;\n    var correction = normalize(delta) * dLambda;\n    let maxCorrection = 0.05; // per iteration - dostosuj w razie potrzeby (0.01-0.1)\n    let corrLen = length(correction);\n    if (corrLen > maxCorrection) {\n        correction = (correction / corrLen) * maxCorrection;\n    }    \n    correction = correction * 0.8;\n    if (wp > 0.0) { particles[att.pIdx].pos += correction * wp; }\n    if (wa > 0.0) { particles[att.aIdx].pos -= correction * wa * (1.0 - att.t); }\n    if (wb > 0.0) { particles[att.bIdx].pos -= correction * wb * att.t; }\n}\n\n@compute @workgroup_size(64)\nfn solveParticleCollisions(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x;\n    if (i >= params.numParticles) { return; }\n    \n    var pi = particles[i];\n    if (pi.invMass <= 0.0) { return; }\n\n    for (var j: u32 = 0u; j < params.numParticles; j++) {\n        if (i == j) { continue; }\n        let pj = particles[j];\n        \n        let delta = pi.pos - pj.pos;\n        let dist = length(delta);\n        let minDist = pi.radius + pj.radius;\n        \n        if (dist < minDist && dist > 0.0001) {\n            let n = delta / dist;\n            let overlap = minDist - dist;\n            let wSum = pi.invMass + pj.invMass;\n            if (wSum > 0.0) {\n                // Jacobi style damping for inter-particle stability\n                pi.pos += n * (overlap / wSum) * pi.invMass * 0.5;\n            }\n        }\n    }\n    particles[i].pos = pi.pos;\n}\n\n@compute @workgroup_size(64)\nfn solveCollisions(@builtin(global_invocation_id) id: vec3<u32>) {\n    let i = id.x;\n    if (i >= params.numParticles) { return; }\n    var p = particles[i];\n    if (p.invMass <= 0.0) { return; }\n\n    let bx = 11.8;\n    let by = 6.8;\n    if (p.pos.x > bx - p.radius) { p.pos.x = bx - p.radius; }\n    if (p.pos.x < -bx + p.radius) { p.pos.x = -bx + p.radius; }\n    if (p.pos.y > by - p.radius) { p.pos.y = by - p.radius; }\n    if (p.pos.y < -by + p.radius) { p.pos.y = -by + p.radius; }\n\n    let circlePos = vec2<f32>(4.0, 2.0);\n    let circleRad = 1.5;\n    let toC = p.pos - circlePos;\n    let dist = length(toC);\n    if (dist < circleRad + p.radius) {\n        p.pos = circlePos + normalize(toC) * (circleRad + p.radius);\n    }\n\n    particles[i].pos = p.pos;\n}"
    },
    {
      "filename": "src/webPhysics.ts",
      "content": "import * as THREE from 'three';\n\nconst MAX_PARTICLES = 16384;\nconst MAX_CONSTRAINTS = 16384;\nconst MAX_ATTACHMENTS = 4096;\n\nexport class WebPhysics {\n    renderer: any;\n    scene: THREE.Scene;\n    bounds: { width: number; height: number };\n    ready: boolean = false;\n\n    particles = new Float32Array(MAX_PARTICLES * 8);\n    distConstraints = new Float32Array(MAX_CONSTRAINTS * 4);\n    attachments = new Float32Array(MAX_ATTACHMENTS * 4);\n\n    numParticles = 0;\n    numDistConstraints = 0;\n    numAttachments = 0;\n    ropes: any[] = [];\n    balls: any[] = [];\n    activeRope: any = null;\n\n    device: GPUDevice | null = null;\n    particleBuffer: GPUBuffer | null = null;\n    distConstraintBuffer: GPUBuffer | null = null;\n    attachmentBuffer: GPUBuffer | null = null;\n    paramsBuffer0: GPUBuffer | null = null;\n    paramsBuffer1: GPUBuffer | null = null;\n    stagingBuffer: GPUBuffer | null = null;\n    bindGroup0: GPUBindGroup | null = null;\n    bindGroup1: GPUBindGroup | null = null;\n\n    pipelines: Record<string, GPUComputePipeline> = {};\n    isReadingBack = false;\n\n    constructor(renderer: any, scene: THREE.Scene, bounds: { width: number; height: number }) {\n        this.renderer = renderer;\n        this.scene = scene;\n        this.bounds = bounds;\n    }\n\n    async init(): Promise<void> {\n        const device = this.renderer.device || this.renderer.backend?.device;\n        if (!device) throw new Error('WebGPU device not found');\n        this.device = device;\n\n        const shaderCode = await (await fetch('/src/physics.wgsl')).text();\n        const shaderModule = device.createShaderModule({ code: shaderCode });\n\n        this.particleBuffer = device.createBuffer({ size: this.particles.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC });\n        this.distConstraintBuffer = device.createBuffer({ size: this.distConstraints.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });\n        this.attachmentBuffer = device.createBuffer({ size: this.attachments.byteLength, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST });\n\n        const paramsSize = 64;\n        this.paramsBuffer0 = device.createBuffer({ size: paramsSize, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });\n        this.paramsBuffer1 = device.createBuffer({ size: paramsSize, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });\n\n        this.stagingBuffer = device.createBuffer({ size: this.particles.byteLength, usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST });\n\n        const bgl = device.createBindGroupLayout({\n            entries: [\n                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'storage' } },\n                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },\n                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'read-only-storage' } },\n                { binding: 3, visibility: GPUShaderStage.COMPUTE, buffer: { type: 'uniform' } }\n            ]\n        });\n\n        const createBG = (pBuf: GPUBuffer) => device.createBindGroup({\n            layout: bgl,\n            entries: [\n                { binding: 0, resource: { buffer: this.particleBuffer! } },\n                { binding: 1, resource: { buffer: this.distConstraintBuffer! } },\n                { binding: 2, resource: { buffer: this.attachmentBuffer! } },\n                { binding: 3, resource: { buffer: pBuf } }\n            ]\n        });\n\n        this.bindGroup0 = createBG(this.paramsBuffer0!);\n        this.bindGroup1 = createBG(this.paramsBuffer1!);\n\n        const layout = device.createPipelineLayout({ bindGroupLayouts: [bgl] });\n        const createPipe = (entry: string) => device.createComputePipeline({ layout, compute: { module: shaderModule, entryPoint: entry } });\n\n        this.pipelines.integrate = createPipe('integrate');\n        this.pipelines.solveDistance = createPipe('solveDistance');\n        this.pipelines.solveAttachments = createPipe('solveAttachments');\n        this.pipelines.solveParticleCollisions = createPipe('solveParticleCollisions');\n        this.pipelines.solveCollisions = createPipe('solveCollisions');\n\n        this.ready = true;\n    }\n\n    spawnBall(pos: THREE.Vector2) {\n        if (this.numParticles >= MAX_PARTICLES) return;\n        const radius = 0.3 + Math.random() * 0.5;\n        const idx = this.numParticles++;\n        this.setParticle(idx, pos, 0.5 / (radius * radius)); // Mass proportional to area\n        this.particles[idx * 8 + 7] = radius;\n\n        const geo = new THREE.CircleGeometry(radius, 16);\n        const mesh = new THREE.Mesh(geo, new THREE.MeshBasicMaterial({ color: 0x00ff88, transparent: true, opacity: 0.9 }));\n        this.scene.add(mesh);\n        this.balls.push({ idx, mesh });\n        this.syncGPU();\n    }\n\n    findAnchor(pos: THREE.Vector2): any | null {\n        const bx = 11.8, by = 6.8, threshold = 0.5;\n        if (Math.abs(pos.x) > bx - threshold || Math.abs(pos.y) > by - threshold) {\n            const snapped = pos.clone();\n            if (bx - Math.abs(pos.x) < threshold) snapped.x = Math.sign(pos.x) * bx;\n            if (by - Math.abs(pos.y) < threshold) snapped.y = Math.sign(pos.y) * by;\n            return { pos: snapped, type: 'static' };\n        }\n        const circlePos = new THREE.Vector2(4, 2);\n        if (pos.distanceTo(circlePos) < 1.5 + threshold) {\n            return { pos: pos.clone().sub(circlePos).normalize().multiplyScalar(1.5).add(circlePos), type: 'static' };\n        }\n        for (const rope of this.ropes) {\n            if (rope === this.activeRope) continue;\n            for (let i = 0; i < rope.segments - 1; i++) {\n                const p1 = this.getParticlePos(rope.indices[i]!);\n                const p2 = this.getParticlePos(rope.indices[i + 1]!);\n                const line = p2.clone().sub(p1), lenSq = line.lengthSq();\n                const t = Math.max(0, Math.min(1, pos.clone().sub(p1).dot(line) / lenSq));\n                const proj = p1.clone().add(line.multiplyScalar(t));\n                if (pos.distanceTo(proj) < 0.25) return { pos: proj, type: 'rope', aIdx: rope.indices[i], bIdx: rope.indices[i + 1], t };\n            }\n        }\n        return null;\n    }\n\n    getParticlePos(i: number) { return new THREE.Vector2(this.particles[i * 8], this.particles[i * 8 + 1]); }\n\n    createRope(anchor: any): any {\n        const segments = 100, restLen = 0.05;\n        const indices: number[] = [], constraintIndices: number[] = [];\n        for (let i = 0; i < segments; i++) {\n            const idx = this.numParticles++;\n            indices.push(idx);\n            const invMass = (i === 0 && anchor.type !== 'rope') ? 0.0 : 1.0;\n            this.setParticle(idx, anchor.pos.clone().add(new THREE.Vector2(0, -i * restLen)), invMass);\n        }\n        if (anchor.type === 'rope') this.addAttachment(indices[0]!, anchor.aIdx, anchor.bIdx, anchor.t);\n        for (let i = 0; i < segments - 1; i++) {\n            const cIdx = this.numDistConstraints++;\n            constraintIndices.push(cIdx); this.setDistConstraint(cIdx, indices[i]!, indices[i + 1]!, restLen, 0.001);\n        }\n        const geo = new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(new Float32Array(segments * 3), 3));\n        const line = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.8 }));\n        const pts = new THREE.Points(geo, new THREE.PointsMaterial({ color: 0xffaa00, size: 0.08 }));\n        this.scene.add(line, pts);\n        const rope = { indices, constraintIndices, mesh: line, pointsMesh: pts, segments, segmentLength: restLen };\n        this.ropes.push(rope); this.activeRope = rope; this.syncGPU();\n        return rope;\n    }\n\n    addAttachment(pIdx: number, aIdx: number, bIdx: number, t: number) {\n        const off = this.numAttachments * 4, uv = new Uint32Array(this.attachments.buffer);\n        uv[off] = pIdx; uv[off + 1] = aIdx; uv[off + 2] = bIdx; this.attachments[off + 3] = t;\n        this.numAttachments++; this.particles[pIdx * 8 + 6] = 1.0;\n    }\n\n    setParticle(i: number, pos: THREE.Vector2, invMass: number): void {\n        const off = i * 8;\n        this.particles[off] = pos.x; this.particles[off + 1] = pos.y;\n        this.particles[off + 2] = pos.x; this.particles[off + 3] = pos.y;\n        this.particles[off + 4] = 0; this.particles[off + 5] = 0;\n        this.particles[off + 6] = invMass; this.particles[off + 7] = 0.04;\n    }\n\n    setDistConstraint(i: number, a: number, b: number, len: number, comp: number): void {\n        const off = i * 4, uv = new Uint32Array(this.distConstraints.buffer);\n        uv[off] = a; uv[off + 1] = b; this.distConstraints[off + 2] = len; this.distConstraints[off + 3] = comp;\n    }\n\n    syncGPU(): void {\n        this.device?.queue.writeBuffer(this.particleBuffer!, 0, this.particles);\n        this.device?.queue.writeBuffer(this.distConstraintBuffer!, 0, this.distConstraints);\n        this.device?.queue.writeBuffer(this.attachmentBuffer!, 0, this.attachments);\n    }\n\n    update(mousePos: THREE.Vector2): void {\n        if (!this.ready || this.isReadingBack) return;\n        const substeps = 12, constraintIters = 6, dt = 1.0 / 60.0;\n        const fill = (phase: number) => {\n            const b = new ArrayBuffer(64), f = new Float32Array(b), u = new Uint32Array(b), i = new Int32Array(b);\n            f[0] = dt; f[1] = -15.0; u[2] = this.numParticles; u[3] = this.numDistConstraints; u[4] = substeps; u[5] = phase; f[6] = mousePos.x; f[7] = mousePos.y; i[8] = this.activeRope ? this.activeRope.indices[this.activeRope.segments - 1] : -1; u[9] = this.numAttachments;\n            return b;\n        };\n        this.device?.queue.writeBuffer(this.paramsBuffer0!, 0, fill(0));\n        this.device?.queue.writeBuffer(this.paramsBuffer1!, 0, fill(1));\n\n        const encoder = this.device!.createCommandEncoder();\n        for (let s = 0; s < substeps; s++) {\n            const intPass = encoder.beginComputePass();\n            intPass.setBindGroup(0, this.bindGroup0!); intPass.setPipeline(this.pipelines.integrate!); intPass.dispatchWorkgroups(Math.ceil(this.numParticles / 64) || 1); intPass.end();\n\n            for (let i = 0; i < constraintIters; i++) {\n                const p0 = encoder.beginComputePass(); p0.setBindGroup(0, this.bindGroup0!); p0.setPipeline(this.pipelines.solveDistance!); p0.dispatchWorkgroups(Math.ceil(this.numDistConstraints / 64) || 1); p0.end();\n                const p1 = encoder.beginComputePass(); p1.setBindGroup(0, this.bindGroup1!); p1.setPipeline(this.pipelines.solveDistance!); p1.dispatchWorkgroups(Math.ceil(this.numDistConstraints / 64) || 1); p1.end();\n                const ap = encoder.beginComputePass(); ap.setBindGroup(0, this.bindGroup0!); ap.setPipeline(this.pipelines.solveAttachments!); ap.dispatchWorkgroups(Math.ceil(this.numAttachments / 64) || 1); ap.end();\n            }\n            // Solve Inter-particle collisions (Balls vs Ropes, Balls vs Balls)\n            const ppCol = encoder.beginComputePass(); ppCol.setBindGroup(0, this.bindGroup0!); ppCol.setPipeline(this.pipelines.solveParticleCollisions!); ppCol.dispatchWorkgroups(Math.ceil(this.numParticles / 64) || 1); ppCol.end();\n\n            const col = encoder.beginComputePass(); col.setBindGroup(0, this.bindGroup0!); col.setPipeline(this.pipelines.solveCollisions!); col.dispatchWorkgroups(Math.ceil(this.numParticles / 64) || 1); col.end();\n        }\n        encoder.copyBufferToBuffer(this.particleBuffer!, 0, this.stagingBuffer!, 0, this.particles.byteLength);\n        this.device?.queue.submit([encoder.finish()]);\n        this.readBackAndVisualize();\n    }\n\n    async readBackAndVisualize() {\n        if (!this.stagingBuffer || this.isReadingBack) return;\n        this.isReadingBack = true;\n        try {\n            await this.stagingBuffer.mapAsync(GPUMapMode.READ);\n            this.particles.set(new Float32Array(this.stagingBuffer.getMappedRange()));\n            this.stagingBuffer.unmap();\n            for (const rope of this.ropes) {\n                const attr = rope.mesh.geometry.getAttribute('position');\n                for (let i = 0; i < rope.segments; i++) attr.setXYZ(i, this.particles[rope.indices[i] * 8]!, this.particles[rope.indices[i] * 8 + 1]!, 0);\n                attr.needsUpdate = true;\n            }\n            for (const ball of this.balls) {\n                const px = this.particles[ball.idx * 8], py = this.particles[ball.idx * 8 + 1];\n                ball.mesh.position.set(px!, py!, -0.1);\n            }\n        } catch (e) { } finally { this.isReadingBack = false; }\n    }\n\n    pinActiveRope(rope: any, anchor: any) {\n        const lastIdx = rope.indices[rope.segments - 1];\n        if (anchor.type === 'static') this.setParticle(lastIdx, anchor.pos, 0.0);\n        else this.addAttachment(lastIdx, anchor.aIdx, anchor.bIdx, anchor.t);\n        rope.mesh.material.color.set(0x00ffff); this.activeRope = null; this.syncGPU();\n    }\n\n    adjustRopeLength(rope: any, delta: number) {\n        rope.segmentLength = Math.max(0.001, Math.min(0.5, rope.segmentLength - delta * 0.005));\n        for (let i = 0; i < rope.constraintIndices.length; i++) this.setDistConstraint(rope.constraintIndices[i], rope.indices[i], rope.indices[i + 1], rope.segmentLength, 0.0);\n        this.device?.queue.writeBuffer(this.distConstraintBuffer!, 0, this.distConstraints);\n    }\n}\n"
    },
    {
      "filename": "tsconfig.json",
      "content": "{\n  \"compilerOptions\": {\n    // Environment setup & latest features\n    \"lib\": [\"ESNext\", \"DOM\", \"DOM.Iterable\", \"WebWorker\"],\n    \"target\": \"ESNext\",\n    \"module\": \"Preserve\",\n    \"moduleDetection\": \"force\",\n    \"jsx\": \"react-jsx\",\n    \"allowJs\": true,\n\n    // Bundler mode\n    \"moduleResolution\": \"bundler\",\n    \"allowImportingTsExtensions\": true,\n    \"verbatimModuleSyntax\": true,\n    \"noEmit\": true,\n\n    // Best practices\n    \"strict\": true,\n    \"skipLibCheck\": true,\n    \"noFallthroughCasesInSwitch\": true,\n    \"noUncheckedIndexedAccess\": true,\n    \"noImplicitOverride\": true,\n\n    // Some stricter flags (disabled by default)\n    \"noUnusedLocals\": false,\n    \"noUnusedParameters\": false,\n    \"noPropertyAccessFromIndexSignature\": false\n  }\n}\n"
    },
    {
      "filename": "vite.config.js",
      "content": "import { defineConfig } from 'vite';\n\nexport default defineConfig({\n  server: {\n    port: 3000,\n    open: true\n  },\n  assetsInclude: ['**/*.wgsl'],\n  build: {\n    target: 'esnext'\n  },\n  optimizeDeps: {\n    esbuildOptions: {\n      target: 'esnext'\n    },\n    include: ['three']\n  },\n  resolve: {\n    alias: {\n      'three/webgpu': 'three/src/renderers/webgpu/WebGPURenderer.js'\n    }\n  }\n});"
    }
  ]
}